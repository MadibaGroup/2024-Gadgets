[{"id":0,"href":"/2024-Gadgets/docs/background/poly-iop/","title":"Poly Iop","section":"Background","content":" Notes on Polynomial Interactive Oracle Proofs (Draft) # Encoding Arrays of Data into Polynomials # Data starts as a array of integers where integers in each slot are between 0 and $q-1$, where $q$ is a large (generally 256 bit) prime number. Recall that we call this set of integers $\\mathbb{Z}_q$.\n$\\mathsf{data}_0$ $\\mathsf{data}_1$ $\\mathsf{data}_2$ $\\mathsf{data}_3$ $\\mathsf{data}_4$ It is common to denote a polynomial like $P(X)$ where $X$ is the variable of the polynomial. We are going denote the variable with an empty box $\\square$ which can be interpreted as a place where you can put any integer in $\\mathbb{Z}_q$ you want evaluated (or equivalent, where you place an x-coordinate to learn what the y-coordinate is).\nA polynomial in this notation looks like:\n$P(\\square)=c_0+c_1\\cdot\\square+c_2\\cdot\\square^2+c_3\\cdot\\square^3+c_4\\cdot\\square^4=\\sum_{i=0}^d c_i\\cdot\\square^i$ The values $c_i$ are called coefficients. Different arrays of data will (depending on how data is encoded, next) result in different coefficients and thus different polynomials. The degree of the polynomial is the largest exponent. So the polynomial above has degree 4 and thus will have 5 coefficients and 5 terms of the form $c_i\\cdot\\square^i$ (including $i=0$). Sometimes the coefficient will be zero: the term is thus not written down but in a list of coefficients, it will be included as a 0.\nThe main question to tackle is how to \u0026ldquo;encode\u0026rdquo; a array of integers into a polynomial. This is generally done one of three ways:\nCoefficients Evaluation Points Roots Each has its advantages and disadvantages, which we discuss next.\nFast forwarding a bit, once the polynomial is created, it is not shared directly with anyone. Instead a commitment to it is shared. The commitment does two things: (1) it makes it succinct: e.g., constant size regardless of how long the array is; and (2) it can hide the data in the array as necessary. We will discuss one specific polynomial commitment scheme called KZG. KZG needs the polynomial in the format of a list of its coefficients. If we have the polynomial in a different form, we will have to convert to coefficients. Thus this needs to be considered when weighing the pros/cons of the three encoding methods.\nEncoding 1: Coefficients # Create polynomial as: $P_1(\\square)=\\mathsf{data}_0+\\square+\\mathsf{data}_2\\cdot\\square^2+\\mathsf{data}_3\\cdot\\square^3+\\mathsf{data}_4\\cdot\\square^4=\\sum_{i=0}^d \\mathsf{data}_i\\cdot\\square^i$\nProperties:\nFast üëç: fastest path to commitment as the output is already in coefficient form. Addition üëç: two arrays can be added together (slot-by-slot) by simply adding the polynomials together Multiplication üëé: no support for multiplication of arrays (Remark: multiplying the polynomials does not multiply the coefficients. It results in a cross multiplication of every term in the first polynomial with every term in the second polynomial. Further the degree of the resulting polynomial will double that of the starting polynomials). Opening ü§∑üèª: proving the value of the $i$th element in the array is $\\mathsf{data}_i$ doing polynomial math on $P_1(\\square)$ is not possible. However $\\Sigma$-protocols done directly on KZG may enable this kind of proof. In any case, this is not particularly well explored. Other useful properties üëç: the sum of all values in a array can be computed by evaluating the polynomial at $P_1(\\boxed{1})$! $\\sum_{i=0}^d \\mathsf{data}_i\\cdot\\boxed{1}^i=\\sum_{i=0}^d \\mathsf{data}_i$ . You can also show two arrays have the same sum (called a \u0026ldquo;sum check\u0026rdquo;) by subtracting them and showing $P(\\boxed{1})=0$. Other useful properties üëç: when all coefficients are 0, the polynomial will be the zero polynomial ($P_1(\\square)=0$). Coefficients can be entire polynomials, not just integers. A common optimization in Poly-IOP systems is taking a set of equations of polynomials that should equal 0, placing each into the coefficient of a super-polynomial, and showing the super-polynomial is the zero polynomial (which can be proven overwhelmingly by showing it is 0 at a randomly selected point). Encoding 2: Evaluation Points # Create a list of points $\\{x,y\\}$ for the data: $\\langle\\{0,\\mathsf{data}_0\\},\\{1,\\mathsf{data}_1\\},\\{2,\\mathsf{data}_2\\},\\{3,\\mathsf{data}_3\\},\\{4,\\mathsf{data}_4\\}\\rangle$ and interpolate a polynomial $P_2(\\square)$ through these points.\nProperties:\nSlow (or moderate) üëé: converting a set of points into a set of coefficients is called interpolation and is $O(n^2)$ time generally. A certain optimization allows $O(n\\log n)$ time by chosing $x$ coordinates with a mathematical relationship (more on this later). Addition üëç: two arrays can be added together (slot-by-slot) by simply adding the polynomials together Multiplication üëç: two arrays can be multiplied together (slot-by-slot) by simply multiplying the polynomials together Opening üëç: proving the value of the $i$th element in the array is $\\mathsf{data}_i$ is possible with polynomial math by showing $P_2(\\boxed{i})=\\mathsf{data}_i$ and KZG has a precise algorithm for this. Encoding 3: Roots # Create polynomial as: $P_3(\\square)=(\\square-\\mathsf{data}_0)(\\square-\\mathsf{data}_1)(\\square-\\mathsf{data}_2)(\\square-\\mathsf{data}_3)(\\square-\\mathsf{data}_4)$\nAlternatively, create a list of roots $\\{x,0\\}$ for the data: $\\langle\\{\\mathsf{data}_0,0\\},\\{\\mathsf{data}_1,0\\},\\{\\mathsf{data}_2,0\\},\\{\\mathsf{data}_3,0\\},\\{\\mathsf{data}_4,0\\}\\rangle$ and interpolate a polynomial $P_3(\\square)$ through these points.\nProperties:\nSlow üëé (or moderate): multiplying out naively requires $O(n^2)$ time. Treating as a set of points and interpolating also requires $O(n^2)$ time (because the x-coordinates are the data, they cannot be chosen freely to optimize interpolation). Applying divide and conquer can provide $O(n \\log^2 n)$.^[1] Addition üëé: two arrays cannot be added from adding (or otherwise manipulating) the polynomials. Multiplication üëé: two arrays cannot be multiplied from multiplying (or otherwise manipulating) the polynomials (but you can do a \u0026ldquo;union\u0026rdquo; operation below). Opening üëç: proving that a value is in the array somewhere is easy and KZG as a precise algorithm for this (opening a root is the same as opening a point, where the y-coordinate is 0). However you cannot show a value is specifically the $i$th value in the array because the polynomial loses the order of the data in the array (see next property). Other useful properties üëç: the order of the data in the array does not matter. The same polynomial will be produced even if the order is changed. This is useful when the array represents a \u0026ldquo;bag\u0026rdquo; of unordered data. You can easily prove two \u0026ldquo;bags\u0026rdquo; of data are the same because the polynomials will be the same. One use-case of this is proving the output of a shuffle/permutation is the same data as the input (just in a different order). Other useful properties üëç: multiplying two polynomials results in a concatenation of the data in the arrays (or conjunction/union of the data in both bags). This might be useful in some protocols. ^[1]: Hat tip Pratyush Mishra.\nDecision Tree for Encoding # Basically we decide if we specifically need unordered \u0026ldquo;bags\u0026rdquo; of data. If so, encoding as roots is the only option. If not, we consider if we need to ever get the data back from the polynomial. Generally we do and encoding as evaluation points is the most common encoding technique. When do we encode the data and never want it back? Usually when (1) the coefficients are all supposed to be zero so we are just showing that property, or (2) we want back the sum of the data and not the data itself. In these cases, you can still work with evaluation point encoding but it will be faster to just do coefficient encoding.\nflowchart LR; A[Array to Polynomial] --\u003e B{Is the data unordered?}; B -- Unordered --\u003e C[Roots]; B -- Ordered or don't care --\u003e D{Open data from polynomial later?}; D -- Yes --\u003e E[Evaluation Points]; D -- No --\u003e F[Coefficients]; The short answer is to start with evaluation point encoding until you realize you need something different.\nOptimizing Interpolation (Roots of Unity + FFT) # Moving forward, we will assume we are using Encoding 2: Evaluation Points. In short, this means placing the elements of our array into the $y$-coordinates ($\\mathsf{data}_i=P(\\boxed{x_i})$) of points on the polynomial. Before commiting to $P(\\square)$, we need to use interpolation to find the coefficients of the polynomial that is fitted to these points. General interpolation algorithms are $O(n^2)$ work for $n$ evaluation points but this can be reduced to $O(n\\log n)$ with an optimization.\nThe optimization we will explore enables interpolation via the fast Fourier transform (FFT). It concerns how to choose the $x$-coordinates, which will serve as the index for accessing the data: evaluating $P(X)$ at $x_i$ will reveal $\\mathsf{data}_i$. First note, $x$-coordinates are from the exponent group ($Z_q$) and the choices exceed what is feasible to use ($2^{255}$ values in bls). Any subset can be used and interpolated. The optimization is to chose them with a mathematical structure. Specifically, instead an additive sequence (e.g., $0,1,2,3,\\ldots$), we use a multiplicative sequence $1,\\omega,\\omega\\cdot\\omega,\\omega\\cdot\\omega\\cdot\\omega,\\ldots$ or equivalently: $\\omega^0,\\omega^1,\\omega^2,\\ldots,\\omega^{\\kappa-1}$. Further, the sequence is closed under multiplication which means that next index after $\\omega^{\\kappa-1}$ wraps back to the first index: $\\omega^{k-1} \\cdot \\omega = \\omega^\\kappa = \\omega^0=1$ (this property is also useful in proving relationships between data in the array and its neighbouring values).\nFor terminology, we say $\\omega$ is a generator with multiplicative order $\\kappa$ in $\\mathbb{Z}_q$ (or $\\omega \\in \\mathbb{G}_\\kappa$). This implies $\\omega^\\kappa=1$. Rearranging, $\\omega=\\sqrt[\\kappa]{1}$. Thus we can equivalently describe $\\omega$ as a $\\kappa$-th root of 1. Finally, as 1 is the unity element in $Z_q$, $\\omega$ is commonly called a $\\kappa$-th root of unity.\nFor practical purposes, $\\kappa$ represents the length of the longest array of data we can use in our protocol. Where does $\\kappa$ come from? Different elements of $Z_q$ will have different multiplicative orders but every order must be a divisor of $q-1$. Thus $\\kappa$ is the largest divisor of the exact value of $q$ used in an elliptic curve standard. BLS12-384 has $\\kappa=2^{32}$ (for terminology, this called a $2$-adicity of $32$). In summary, we can only encode data arrays of length up to $2^{32}=4,294,967,296$.\nZeroing Parts of an Array # Assuming an input array of size $n$: $\\langle \\mathsf{data}_0,\\mathsf{data}_1,\\ldots,\\mathsf{data}_{n-1}\\rangle$ and input array encoded into the polynomial. This uses \u0026ldquo;Encoding 2\u0026rdquo; from above (evaluation points) and uses \u0026ldquo;Roots of Unity + FFT\u0026rdquo; from above where $\\omega\\in\\mathbb{G}_\\kappa$ is a generator for the x-coordinates of the points.\n$\\bot$ is an arbitrary non-zero integer.\nOperation Input Array Input Polynomial Output Array Output Polynomial Zero all $\\langle 3,1,3,3,7 \\rangle$ $P(X)$ $\\langle 0,0,0,0,0 \\rangle$ $P(X)\\cdot(X^n-1)$ Zero first $\\langle 3,1,3,3,7 \\rangle$ $P(X)$ $\\langle 0,\\bot,\\bot,\\bot,\\bot \\rangle$ $P(X)\\cdot(X-\\omega^0)$ Zero last $\\langle 3,1,3,3,7 \\rangle$ $P(X)$ $\\langle \\bot,\\bot,\\bot,\\bot,0 \\rangle$ $P(X)\\cdot(X-\\omega^{n-1})$ Zero all but first $\\langle 3,1,3,3,7 \\rangle$ $P(X)$ $\\langle \\bot,0,0,0,0 \\rangle$ $P(X)\\cdot\\frac{(X^n-1)}{(X-\\omega^0)}$ Zero all but last $\\langle 3,1,3,3,7 \\rangle$ $P(X)$ $\\langle 0,0,0,0,\\bot \\rangle$ $P(X)\\cdot\\frac{(X^n-1)}{(X-\\omega^{n-1})}$ Why are these useful? Consider a range proof from Boneh, Fisch, Gabizon, and Williamson. At a certain point in the protocol, we reach the following:\nFirst note that $w$ and $\\omega$ look the same but are different: $w$ are three new polynomials we are creating, while $\\omega$ is the generator of $\\mathbb{G}_\\kappa$ we are using to pick x-coordinates for the polynomials.\nIn the first constraint, we want to prove the value of f(1) and g(1) are the same. So we subtract (g-f) which leaves a zero in the first element of the array but the rest of the array will contain other stuff. By applying \u0026ldquo;zero all but first\u0026rdquo;, we can zero out the rest of the array. We now have an array that is all zero (in polynomial form, this is called a vanshing polynomial and we can prove a polynomial vanishes easily and in a batch). In the second constraint, we prove the last element in g is a binary bit (0 or 1) and then we apply the \u0026ldquo;zero all but last\u0026rdquo; to make an array that is all zero (and vanishing polynomial). In the third constraint, the first two terms of the multiplication are proving $g(X)$ has a certain form that does not need to be understood here. What is important is that there is a relationship between each integer in the array ($g(X)$) and the integer right beside it ($g(X\\omega)$) in the array. When the relationship holds, the result is a zero in $w_3$. Unfortunately, there is a corner case: for the last element in the array, the \u0026ldquo;next\u0026rdquo; integer wraps back to the first integer and the relationship does not hold across this boundary. So we use \u0026ldquo;zero last\u0026rdquo; to manually zero out the last integer in the array, leaving us with a zero array (and vanishing polynomial). KZG Commitments # KZG is a commitment scheme, designed specifically for polynomials. While any commitment scheme can be used to commit to a polynomial (e.g., hash the polynomial) and later reveal it, KZG has homomorphic properties that are useful for polynomials. They are as follows:\nAddition. $\\mathsf{Comm}$ Multiplication Check. $P_1(z)\\cdot P_2(z) - P_3(z)=0$ Evaluation Check. g^P(X) -\u0026gt; g^(c_0+c_1X+c_2X^2)\nEvaluate at tau to commit\nTrusted setup (Powers of Tau) -\u0026gt; $g,g^{\\tau}, g^{\\tau^2}$\nArray: [4, 6, 7, 2, 346, 24\u0026hellip;]\nArray -\u0026gt; Polynomial -\u0026gt; Polynomial Commitment (Poly-IOP; polynomial interactive oracle proof)\nArray -\u0026gt; Polynomial -\u0026gt; How?\nEvaluation points -\u0026gt; [{1,4},{2,6},{3,7}\u0026hellip;] -\u0026gt; Lagrange / FFT interpolation Roots -\u0026gt; [{4,0},{6,0},{7,0},..] -\u0026gt; Interpolation is sufficient, not necessary -\u0026gt; Expansion -\u0026gt; (X-4)(X-6)(X-7) Coefficients -\u0026gt; 4+6X+7X^2 -\u0026gt; Nothing KZG: $g^{c_0+c_1*\\tau+c_2*\\tau^2+\\ldots}$\nComm(P1)*Comm(P2) = Comm (P1+P2)\nComm(P1)^P2=Comm(P1*P2)\nComm(P1)^a=Comm(a*P1)\nOpen Root (z=P1(0))\nOpen a root at 7 Q=(X-4)(X-6)(X-7) / (X-7) -\u0026gt; evenly divide iff 7 is a root Q(X-7) = P -\u0026gt; check with pairing Open point (z=P1(x))\nSubtract off z and now x is a root, see above Batch opening many points:\nOpen many points on same polynomial P Open the same point on many polynomials Open many points on many polynomials -\u0026gt; not sure? $P_1(X)=c_0+c_1*X+\\ldots$\n$P_3(\\square)=(\\square-\\mathsf{data}_0)(\\square-\\mathsf{data}_1)$\n$P_3(\\square)=((\\square-\\mathsf{data}_2)(\\square-\\mathsf{data}_3)(\\square-\\mathsf{data}_4)$\n$P_3(\\square)=(\\square-\\mathsf{data}_0)(\\square-\\mathsf{data}_1)(\\square-\\mathsf{data}_2)(\\square-\\mathsf{data}_3)(\\square-\\mathsf{data}_4)$\n"},{"id":1,"href":"/2024-Gadgets/docs/gadgets/mult2/","title":"Mult2","section":"Gadgets","content":" Multiplication (within polynomial) # Array-level # Given array $\\mathsf{Arr}_1$ of length $\\ell$ and integer $\\mathsf{Prod}_1$, demonstrate that $\\mathsf{Prod}=\\prod_{i=0}^{\\ell-1}\\mathsf{Arr}_1[i]$.\nBuild accumulator array $\\mathsf{Acc}_1$ from $\\mathsf{Arr}_1$ as follows: $\\mathsf{Acc}_1[\\ell-1]=\\mathsf{Arr}_1[\\ell-1]$ $\\mathsf{Acc}_1[i]=\\mathsf{Arr}_1[i]\\cdot \\mathsf{Acc}_1[i+1]$‚Äã If built correctly, $\\mathsf{Acc}_1[0]=\\mathsf{Prod}_1$ Example:\nChecked input: $\\mathsf{Prod}_1=66$ Unchecked input: $\\mathsf{Arr}_1=\\langle 84,67,11,92,36,67 \\rangle$ Execution trace: $\\mathsf{Acc}_1= \\langle \\bot,\\bot,\\bot,\\bot,\\bot,67 \\rangle$‚Äã $\\mathsf{Acc}_1= \\langle \\bot,\\bot,\\bot,\\bot,(36\\cdot 67),67 \\rangle$ $\\mathsf{Acc}_1= \\langle \\bot,\\bot,\\bot,\\bot,84,67 \\rangle$‚Äã $\\mathsf{Acc}_1= \\langle \\bot,\\bot,\\bot,(92\\cdot 84),84,67 \\rangle$ Polynomial-level # Commitment-level # "},{"id":2,"href":"/2024-Gadgets/docs/gadgets/productgadget/","title":"Product Gadget","section":"Gadgets","content":"Array Level\nProver has A = {a, b, c, d, e} and wants to show the $\\prod A= z$ Prover computes the accumulator B = {abcde, bcde, cde, de, e} To prove $\\prod A= z$, it suffices to show that (i) $abcde = z$ and (ii) $B_i = A_iB_{i+1} \\forall i$‚Äã‚Äã Note that (ii) doesn\u0026rsquo;t hold in general for $i = n -1$, the last entry of A. We can deal with the simpler special case $z = 1$, and separately for $z \\neq 1$‚Äã For $z = 1$, (ii) holds for $n - 1$, assuming the indices wrap around (this works if we use an nth root of unity, where n is the length of the array) For $z \\neq 1$, the edge case will be fixed with an extra condition when we define our polynomial Polynomial Level\nThe prover interpolates A and B to get $P_A(x)$ and $P_B(x)$, with the y values as the entries in the array and the x values as powers of an nth root of unity. For example $P_A(X)$ passes through ($\\omega^0$, a), ($\\omega^1$, b), ($\\omega^2$, c), ($\\omega^3$, d), ($\\omega^4$, e) The prover then commits to these two polynomials (e.g. with KZG) The prover also commits to $P_{B'}(x):= P_{B}(x \\cdot \\omega)$. In other words, $P_B'(x)$ is the interpolation of the array $B'$ such that $B'_i = B_{i + 1}$, except $B'_{n-1}$, which is equal to $B_0$ To prove $abcde = z$ the prover simply opens the commitment to $P_B(x)$ at $x = \\omega^0 = 1$‚Äã To prove $B_i = A_iB_{i-1} \\forall i$ we define $Q(X) = P_A(x)P_{B'}(x) - P_B(x)$ and show it vanishes for $x = \\omega^i$ for $0 \\leq i \\leq n-1$ (this is a separate gadget) For $z \\neq 1$ we fix the edge case by multiplying $Q(x)$ by $(x - \\omega^{n-1})$, making $\\omega^{n-1}$ a root. Then $Q(x)$ vanished at $\\omega^{n-1}$, even though $B_i = A_iB_{i-1} \\forall i$ doesn\u0026rsquo;t hold for $i = n - 1$. In this case, $Q(X) = (P_A(x)P_{B'}(x) - P_B(x))(x - \\omega^{n-1})$ Verifier Level\nverify $P_A(x)$ and $P_B(x)$ are correct interpolations of A and B (checking $Q(x)$‚Äã vanishes is checking they are defined properly in terms of each other - do we have to verify that they accurately correspond to the array in any way?)\nverify $P_{B'}(x)$ is correct, i.e. $P_{B'}(x) = P_{B}(x \\omega)$. To do so, the verifier sends a random challenge value $u$. The prover then sends $P_{B'}(u), P_{B}(u\\omega)$ and $u\\omega$ as well as a proof $\\pi$ that these openings are correct. If the proof $\\pi$ is correct and $P_B'(u) = P_B(u\\omega)$, then with high probability we can say that $P_{B'}(x) = P_B(x\\omega)$. By the Fiat-Shamir, this can also be done non-interactively.\nverify opening of $P_A(x)$‚Äã at $x = \\omega^0 = 1$ (KZG let\u0026rsquo;s us do this)\nverify $Q(x)$ is defined properly; this can be done using the commitments to $P_A(x)$, $P_B(x)$, and $P_{B'}(x)$ which the verifier has, and a pairing operation. The verifier wishes to check the following:\n‚Äã\t$comm(Q(x)) = comm(P_A(x)) \\cdot P_{B'}(x) - P_B(x))$‚Äã‚Äã\nBy the homomorphic property of the commitment, we could rewrite the equation as the following:\n‚Äã\t$comm(Q(x)) = comm(P_A(x)) \\cdot P_{B'}(x)) - comm(P_B(x))$‚Äã\nBut then we get stuck trying to deal with the mulitplication. Instead, the verifier must use a pairing operation to check the equality. First, we will rewrite our equation in terms of the group element used for the commitment:\n‚Äã\t$g^{Q(\\tau)} = g^{P_A(\\tau) \\cdot P_{B'}(\\tau) - P_B(\\tau)}$‚Äã\nNow, we note the above equation holds if and only if the following equation (using pairings) holds:\n‚Äã\t$e(g,g)^{Q(\\tau)}= e(g, g)^{P_A(\\tau)\\cdot P_{B'}(\\tau) - P_B(\\tau)}$‚Äã\nWhich is equivalent to:\n‚Äã\t$e(g, g^{Q(\\tau)}) = e(g^{P_A(\\tau)}, g^{P_{B'}(\\tau)}) \\cdot e(g, (g^{P_B(\\tau)})^{-1})$‚Äã‚Äã\nThus this equation, which the verifier can calculate, is used to verify that $Q(x)$ is the correct polynomial.\nneed to verify $Q(x)$ vanished on $x = \\omega^i$ for $0 \\leq i \\leq n-1$ (this is a separate gadget)\n"}]