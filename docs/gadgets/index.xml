<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Handbook</title><link>http://plonkbook.org/docs/gadgets/</link><description>Recent content on Handbook</description><generator>Hugo</generator><language>en-us</language><atom:link href="http://plonkbook.org/docs/gadgets/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://plonkbook.org/docs/gadgets/add1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/add1/</guid><description>Addition (Type 1) # Recap of types # Type Description Recap This add1 $\mathsf{Arr}_3=\mathsf{Arr}_1 + \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise addition of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. ✅ add2 $\mathsf{Sum}_\mathsf{Arr}=\sum_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Sum}_\mathsf{Arr}$ is the disclosed sum of all the elements in $\mathsf{Arr}$. add3 $\sum_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\sum_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed sum. Relation # $ \mathcal{R}_{\mathtt{add1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr_2},K_\mathsf{Arr_3}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_3}[i]=\mathsf{Arr_1}[i]+\mathsf{Arr_2}[i], 0\leq i \leq n, \\ \mathsf{Poly}_\mathsf{Arr_j}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/add2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/add2/</guid><description>Addition (Type 2) # Recap of types # Type Description Recap This add1 $\mathsf{Arr}_3=\mathsf{Arr}_1 + \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise addition of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. add2 $\mathsf{Sum}_\mathsf{Arr}=\sum_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Sum}_\mathsf{Arr}$ is the disclosed sum of all the elements in $\mathsf{Arr}$. ✅ add3 $\sum_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\sum_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed sum. Relation # $ \mathcal{R}_{\mathtt{add2}} := \left\{ \begin{array}{l} (K_\mathsf{Arr},\mathsf{Sum}_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} \mathsf{Arr} = [a_0, a_1, a_2, \dots, a_{n-1}], \\ \mathsf{Sum}_\mathsf{Arr} = \sum_{i = 0}^{n-1} a_i, \\ \mathsf{Poly}_\mathsf{Arr}(X)=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/add3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/add3/</guid><description>Addition (Type 3) # Recap of types # Type Description Recap This add1 $\mathsf{Arr}_3=\mathsf{Arr}_1 + \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise addition of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. add2 $\mathsf{Sum}_\mathsf{Arr}=\sum_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Sum}_\mathsf{Arr}$ is the disclosed sum of all the elements in $\mathsf{Arr}$. add3 $\sum_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\sum_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed sum. ✅ Relation # $ \mathcal{R}_{\mathtt{add3}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/circuit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/circuit/</guid><description>Circuit # Recap of types # Type Description Recap This circuit $z=\mathsf{Circ}(x,y)$ $z$ is the output of disclosed arithmetic circuit $\mathsf{Circ}$ with disclosed (and/or undisclosed) inputs $x$ and $y$. ✅ Relation # $\mathcal{R}_{\mathtt{circ}} := \left\{ \begin{array}{l} (K_\mathsf{T},K_\mathsf{In}) \end{array} \middle | \begin{array}{l} \mathsf{In}=[i_0,i_1,i_2,i_3], \\ \mathsf{T}=[t_0,t_1,t_2,t_3], \\ \mathsf{T}[3]\in\{0,1\}, \\ \mathsf{T}[3]\cdot(\mathsf{In}[0]\cdot\mathsf{T}[0]+\mathsf{In}[1]\cdot\mathsf{T}[1])+(1-\mathsf{T}[3])\cdot(\mathsf{In}[0]\cdot\mathsf{In}[1]\cdot\mathsf{T}[2])+\mathsf{In}[2]=\mathsf{In}[3], \\ \mathsf{Poly}_\mathsf{T}=\mathsf{FFT.Interp}(\omega,\mathsf{T}), \\ \mathsf{Poly}_\mathsf{In}=\mathsf{FFT.Interp}(\omega,\mathsf{In}), \\ K_\mathsf{T}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{T}), \\ K_\mathsf{In}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{In}) \\ \end{array} \right\}$
Intuition # The prover ($\mathcal{P}$) and the verifier ($\mathcal{V}$) are both given a circuit $\mathsf{T}$, where $\mathsf{T}[0]$ and $\mathsf{T}[1]$ are the coefficients of the two inputs respectively, $\mathsf{T}[2]$ is the coefficient of the product of the two inputs, and $\mathsf{T}[3]$ is the selector of the gate ($\mathsf{T}[3]$ is one for addition gate and zero for multiplication gate).</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/concat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/concat/</guid><description>Concatenation # Recap of types # Type Description Recap This concat $\mathsf{Arr}_3=\mathsf{Arr}_1\cup\mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the concatenation of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ ✅ Relation # $$ \mathcal{R}_{\mathtt{mult1}} := \left\{ \begin{array}{l} (K_{\mathsf{Arr}_1},K_{\mathsf{Arr}_2},K_{\mathsf{Arr}_3}) \end{array} \middle | \begin{array}{l} \mathsf{Arr}_3=\mathsf{Arr}_1\cup\mathsf{Arr}_2, \\ \mathsf{Arr}_3[i]=\mathsf{Arr}_1[i],i\in[0,n_1), \\ \mathsf{Arr}_3[i+n_1]=\mathsf{Arr}_2[i],i\in[0,n_2), \\ \mathsf{Poly}_\mathsf{Arr_j}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr_j}), 1\leq j \leq 3, \\ K_\mathsf{Arr_j}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr_j}), 1\leq j \leq 3, \end{array} \right\} $$ Intuition # The prover ($\mathcal{P}$) holds three arrays $\mathsf{Arr}_1$, $\mathsf{Arr}_2$ and $\mathsf{Arr_3}$. He wants to convince the verifier ($\mathcal{V}$) $\mathsf{Arr}_3$ is the concatenation of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/encode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/encode/</guid><description>Encode # Relation # $ \mathcal{R}_{\mathtt{mult3}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}, \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr_1}), \\ \mathsf{Poly}_\mathsf{Arr_2}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr_2}), \\ K_\mathsf{Arr_1}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr_1}),\\ K_\mathsf{Arr_2}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr_2}), \end{array} \right\} $
Intuition # The prover ($\mathcal{P}$) holds two arrays $\mathsf{Arr_1}$ and $\mathsf{Arr_2}$ of $n$ integers from $\mathbb{Z}_q$: $[a_0, a_1, a_2, \dots, a_{n-1}]$. It wishes to map the pairs of elements, $\{ \mathsf{Arr_1[i], \mathsf{Arr_2[i]}}\}$ into a single element, $\mathsf{Arr_3}[i]$ without collisions.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/lookup1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/lookup1/</guid><description>Lookup (Type 1) # Recap of types # Type Description Recap This lookup1 $\mathsf{Arr}[i]\in \{0,1\}$ Each element of array $\mathsf{Arr}$ is in $\{0,1\}$ (or another small set). ✅ lookup2 $\mathsf{Arr}[i]\in \mathsf{Table}$ Each element of array $\mathsf{Arr}$ is in a disclosed table of values $\mathsf{Table}$. Relation # $ \mathcal{R}_{\mathtt{lookup1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} \mathsf{Arr} = [a_0, a_1, a_2, \dots, a_{n-1}], \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \end{array} \right\} $</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/lookup2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/lookup2/</guid><description>Lookup (Type 2) # Recap of types # Type Description Recap This lookup1 $\mathsf{Arr}[i]\in \{0,1\}$ Each element of array $\mathsf{Arr}$ is in $\{0,1\}$ (or another small set). lookup2 $\mathsf{Arr}[i]\in \mathsf{Table}$ Each element of array $\mathsf{Arr}$ is in a disclosed table of values $\mathsf{Table}$. ✅ Relation # $ \mathcal{R}_{\mathtt{lookup2}} := \left\{ \begin{array}{l} (\mathsf{Arr},\mathsf{T}) \end{array} \middle | \begin{array}{l} \mathsf{Arr}[i]\in\mathsf{T}, 0\leq i \leq n-1, \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ \mathsf{Poly}_\mathsf{T}=\mathsf{FFT.Interp}(\omega,\mathsf{T}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \\ K_\mathsf{T}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{T}), \end{array} \right\} $</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/mult1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/mult1/</guid><description>Multiplication (Type 1) # Recap of types # Type Description Recap This mult1 $\mathsf{Arr}_3=\mathsf{Arr}_1 \cdot \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise multiplication of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. ✅ mult2 $\mathsf{Prod}_\mathsf{Arr}=\prod_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Prod}_\mathsf{Arr}$ is the disclosed product of all the elements in $\mathsf{Arr}$. mult3 $\prod_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\prod_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed product. Relation # $ \mathcal{R}_{\mathtt{mult1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr_2},K_\mathsf{Arr_3}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_3}[i]=\mathsf{Arr_1}[i]\cdot\mathsf{Arr_2}[i], 0\leq i \leq n-1, \\ \mathsf{Poly}_\mathsf{Arr_j}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/mult2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/mult2/</guid><description>Multiplication (Type 2) # Recap of types # Type Description Recap This mult1 $\mathsf{Arr}_3=\mathsf{Arr}_1 \cdot \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise multiplication of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. mult2 $\mathsf{Prod}_\mathsf{Arr}=\prod_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Prod}_\mathsf{Arr}$ is the disclosed product of all the elements in $\mathsf{Arr}$. ✅ mult3 $\prod_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\prod_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed product. Relation # $ \mathcal{R}_{\mathtt{mult2}} := \left\{ \begin{array}{l} (K_\mathsf{Arr},\mathsf{Prod}_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} \mathsf{Arr} = [a_0, a_1, a_2, \dots, a_{n-1}], \\ \mathsf{Prod}_\mathsf{Arr} = \prod_{i = 0}^{n-1} a_i, \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/mult3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/mult3/</guid><description>Multiplication (Type 3) # Recap of types # Type Description Recap This mult1 $\mathsf{Arr}_3=\mathsf{Arr}_1 \cdot \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise multiplication of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. mult2 $\mathsf{Prod}_\mathsf{Arr}=\prod_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Prod}_\mathsf{Arr}$ is the disclosed product of all the elements in $\mathsf{Arr}$. mult3 $\prod_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\prod_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed product. ✅ Relation # $ \mathcal{R}_{\mathtt{mult3}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/range/</guid><description>Range # Recap of types # Type Description Recap This range $\mathsf{Arr}[i]\in[0,r]$ Each element of array $\mathsf{Arr}$ is in the range $[0,r]$ ✅ Relation # $\mathcal{R}_{\mathtt{add1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} 0\le{\mathsf{Arr}[i]}\le{r}, i\in[0,n), \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \end{array} \right\}$
Intuition # To prove each element of array $\mathsf{Arr}$ is in the range $[0,r]$, one of the most intuitive ways is we create a vector containing the numbers from $0$ to $r$ and run the lookup argument for $\mathsf{Arr}$.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/rotate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/rotate/</guid><description>Rotate # Recap of types # $ \mathcal{R}_{\mathtt{rotate}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}, K_\mathsf{Arr'}) \end{array} \middle | \begin{array}{l} \mathsf{Arr} = [a_0, a_1, a_2, \dots, a_{n-1}],\\ \mathsf{Arr'}[i] = \mathsf{Arr}[i +\alpha], \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}),\\ \mathsf{Poly}_\mathsf{Arr'}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr'}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}),\\ K_\mathsf{Arr'}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr'}),\\ \end{array} \right\} $
Intuition # Assume $\mathsf{Arr}$ is an array of data of size $n$. It is encoded as the y-coordinates into univariant polynomials where the x-coordinates (called the domain $\mathcal{H}_\kappa$) are chosen as the multiplicative group of order $\kappa$ with generator $\omega\in\mathbb{G}_\kappa$ (see Background for more).</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/sangria/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/sangria/</guid><description>Sangria # Intuition # Given a PLONK circuit, and two private input/public input pairs, we want to reduce the work of checking each of these individually to the work of checking such a relation a single time. This is called folding. First, though, let&amp;rsquo;s review how a PLONK circuit works.
In circuit we look at how a circuit with a single gate works, but here we generalize to multi-gate circuits.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/shuffle1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/shuffle1/</guid><description>Shuffle (Type 1) # Recap of types # Type Description Recap This shuffle1 $\mathsf{Arr}_2=\mathsf{Permute}(\mathsf{Arr}_1)$ Array $\mathsf{Arr}_2$ is a shuffle of $\mathsf{Arr}_1$ for some undisclosed permutation $\pi$. ✅ shuffle2 $\mathsf{Arr}_2=\mathsf{Permute}(\mathsf{Arr}_1 ,\pi)$ Array $\mathsf{Arr}_2$ is a shuffle of $\mathsf{Arr}_1$ under a disclosed permutation $\pi$. Relation # $ \mathcal{R}_{\mathtt{shuffle1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/shuffle2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/shuffle2/</guid><description>Shuffle (Type 2) # Recap of types # Type Description Recap This shuffle1 $\mathsf{Arr}_2=\mathsf{Permute}(\mathsf{Arr}_1)$ Array $\mathsf{Arr}_2$ is a shuffle of $\mathsf{Arr}_1$ for some undisclosed permutation $\pi$. shuffle2 $\mathsf{Arr}_2=\mathsf{Permute}(\mathsf{Arr}_1 ,\pi)$ Array $\mathsf{Arr}_2$ is a shuffle of $\mathsf{Arr}_1$ under a disclosed permutation $\pi$. ✅ Relation # $\mathcal{R}_{\mathtt{shuffle2}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}, K_\pi) \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Arr_\pi} = [\pi(\omega^0), \pi(\omega^1), \pi(\omega^2), \dots, \pi(\omega^{n-1})], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/zero1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/zero1/</guid><description>Zero (Type 1) # Recap of types # Type Description Recap This zero1 $\mathsf{Arr}[i]\leftarrow0$ Zero-out elements of an array $\mathsf{Arr}$ such as: all, first, last, all-but-first, all-but-last. ✅ zero2 $\mathsf{Arr}[i]\leftarrow0$ iff $\mathsf{Sel}[i]=0$ Zero-out elements of an array $\mathsf{Arr}$ according to a binary array $\mathsf{Sel}$. Subtypes of $\texttt{zero1}$ # Operation Output Array Zero all $\langle 0,0,0,0,0 \rangle$ Zero first $\langle 0,\bot,\bot,\bot,\bot \rangle$ Zero last $\langle \bot,\bot,\bot,\bot,0 \rangle$ Zero all but first $\langle \bot,0,0,0,0 \rangle$ Zero all but last $\langle 0,0,0,0,\bot \rangle$ Relation # Shown for &amp;ldquo;zero last&amp;rdquo; but can be adapted to the other sub-types of $\texttt{zero1}$:</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/zero2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/zero2/</guid><description>Zero (Type 2) # Recap of types # Type Description Recap This zero1 $\mathsf{Arr}[i]\leftarrow0$ Zero-out elements of an array $\mathsf{Arr}$ such as: all, first, last, all-but-first, all-but-last. zero2 $\mathsf{Arr}[i]\leftarrow0$ iff $\mathsf{Sel}[i]=0$ Zero-out elements of an array $\mathsf{Arr}$ according to a binary array $\mathsf{Sel}$. ✅ Zeroing Parts of an Array (2) # Assume both $\mathsf{Arr}$ (an array of data) and $\mathsf{Sel}$ (a binary array) are of size $n$. They are encoded as the y-coordinates into univariant polynomials where the x-coordinates (called the domain $\mathcal{H}_\kappa$) are chosen as the multiplicative group of order $\kappa$ with generator $\omega\in\mathbb{G}_\kappa$ (see Background for more).</description></item></channel></rss>