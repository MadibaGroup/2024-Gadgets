<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Range # Recap of types # Type Description Recap This range $\mathsf{Arr}[i]\in[0,r]$ Each element of array $\mathsf{Arr}$ is in the range $[0,r]$ ✅ Relation # $\mathcal{R}_{\mathtt{add1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} 0\le{\mathsf{Arr}[i]}\le{r}, i\in[0,n), \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \end{array} \right\}$
Intuition # To prove each element of array $\mathsf{Arr}$ is in the range $[0,r]$, one of the most intuitive ways is we create a vector containing the numbers from $0$ to $r$ and run the lookup argument for $\mathsf{Arr}$."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://plonkbook.org/docs/gadgets/range/"><meta property="og:site_name" content="Handbook"><meta property="og:title" content="Handbook"><meta property="og:description" content="Range # Recap of types # Type Description Recap This range $\mathsf{Arr}[i]\in[0,r]$ Each element of array $\mathsf{Arr}$ is in the range $[0,r]$ ✅ Relation # $\mathcal{R}_{\mathtt{add1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} 0\le{\mathsf{Arr}[i]}\le{r}, i\in[0,n), \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \end{array} \right\}$
Intuition # To prove each element of array $\mathsf{Arr}$ is in the range $[0,r]$, one of the most intuitive ways is we create a vector containing the numbers from $0$ to $r$ and run the lookup argument for $\mathsf{Arr}$."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Range | Handbook</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=http://plonkbook.org/docs/gadgets/range/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.6d49e6d62f7a22810d59163850ad225ab79a5baf5608bfeea8d7c48676951f3e.js integrity="sha256-bUnm1i96IoENWRY4UK0iWreaW69WCL/uqNfEhnaVHz4=" crossorigin=anonymous></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Handbook</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><p><strong>Background</strong></p></li><li><p><a href=/docs/background/overview/>Overview</a></p></li><li><p><a href=/docs/background/kzg/>KZG</a></p></li><li><p><a href=/docs/background/poly-iop/>Poly IOP</a></p></li><li><p><a href=/docs/background/red-tape/>Red Tape</a></p></li><li><p><a href=/docs/background/proofs/>Proofs</a></p></li><li><p><strong>Gadgets</strong></p></li><li><p><a href=/docs/gadgets/zero1/>zero1</a></p></li><li><p><a href=/docs/gadgets/zero2/>zero2</a></p></li><li><p><a href=/docs/gadgets/rotate/>rotate</a></p></li><li><p><a href=/docs/gadgets/add1/>add1</a></p></li><li><p><a href=/docs/gadgets/add2/>add2</a></p></li><li><p><a href=/docs/gadgets/add3/>add3</a></p></li><li><p><a href=/docs/gadgets/mult1/>mult1</a></p></li><li><p><a href=/docs/gadgets/mult2/>mult2</a></p></li><li><p><a href=/docs/gadgets/mult3/>mult3</a></p></li><li><p><a href=/docs/gadgets/encode/>encode</a></p></li><li><p><a href=/docs/gadgets/shuffle1/>shuffle1</a></p></li><li><p><a href=/docs/gadgets/shuffle2/>shuffle2</a></p></li><li><p><a href=/docs/gadgets/lookup1/>lookup1</a></p></li><li><p><a href=/docs/gadgets/lookup2/>lookup2</a></p></li><li><p><a href=/docs/gadgets/concat/>concat</a></p></li><li><p><a href=/docs/gadgets/range/ class=active>range</a></p></li><li><p><a href=/docs/gadgets/circuit/>circuit</a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Range</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#recap-of-types>Recap of types</a></li><li><a href=#relation>Relation</a></li><li><a href=#intuition>Intuition</a></li><li><a href=#protocol-details>Protocol Details</a><ul><li><a href=#array-level>Array Level</a></li><li><a href=#polynomial-level>Polynomial Level</a></li><li><a href=#commitment-level>Commitment Level</a></li></ul></li><li><a href=#security-proof>Security Proof</a><ul><li><a href=#completeness>Completeness</a></li><li><a href=#soundness>Soundness</a></li><li><a href=#zero-knowledge>Zero-Knowledge</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=range>Range
<a class=anchor href=#range>#</a></h1><h2 id=recap-of-types>Recap of types
<a class=anchor href=#recap-of-types>#</a></h2><table><thead><tr><th>Type</th><th>Description</th><th>Recap</th><th>This</th></tr></thead><tbody><tr><td>range</td><td>$\mathsf{Arr}[i]\in[0,r]$</td><td>Each element of array $\mathsf{Arr}$ is in the range $[0,r]$</td><td>✅</td></tr></tbody></table><h2 id=relation>Relation
<a class=anchor href=#relation>#</a></h2><p>$\mathcal{R}_{\mathtt{add1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} 0\le{\mathsf{Arr}[i]}\le{r}, i\in[0,n), \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \end{array} \right\}$</p><h2 id=intuition>Intuition
<a class=anchor href=#intuition>#</a></h2><p>To prove each element of array $\mathsf{Arr}$ is in the range $[0,r]$, one of the most intuitive ways is we create a vector containing the numbers from $0$ to $r$ and run the lookup argument for $\mathsf{Arr}$. Another approach is we prove each element is in $[0,r]$. Specifically, we decompose the target number to digits in some base $x$ and prove (i) the digits are valid and (ii) the number can be recovered from the digits and the base. The prover ($\mathcal{P}$) holds a number $\eta$ and $\mathsf{Arr}$ of $k=\lceil\log_x{\eta}\rceil$ integers from $\mathbb{Z}_q$: $[a_0,a_1,a_2,\dots,a_{k-1}]$. It will produce a succinct (logarithm base $x$ of $\eta$. For simplicity, we will use base $2$) proof that the vector $\mathsf{T}$ satisfies the following conditions: (i) the first value of $\mathsf{T}$ equals to $\eta$ (ii) the last value of $\mathsf{T}$ equals to one or zero (iii) any value minus two times the next value is equal to one or zero in $\mathsf{T}$. The prover will encode $\mathsf{Arr}$ and $\mathsf{T}$ into two polynomials: $\mathsf{Poly}_\mathsf{Arr}$ and $\mathsf{Poly}_\mathsf{T}$ (using <a href>evaluation points</a> on the domain $\mathcal{H}_\kappa$). He will commit to each polynomial: $K_\mathsf{Arr}$ and $K_\mathsf{T}$. The verifier ($\mathcal{V}$) cannot check any of the $\mathsf{Arr}$, $\mathsf{T}$ or $\mathsf{Poly}_\mathsf{Arr}$, $\mathsf{Poly}_\mathsf{T}$ values directly. Instead the verifier only sees $K_\mathsf{Arr}$, and $K_\mathsf{T}$.</p><p>In order to prove $K_\mathsf{Arr}$ and $K_\mathsf{T}$ satisfy the above three conditions, one of the most straightforward methods is to use the additive homomorphic property of the KZG commitment scheme, i.e., prove $K_\mathsf{Arr}$ and $K_\mathsf{T}$ satisfy the conditions through the group addition. This method works if the target condition only involves additive operations. However, there are multiplications in the above conditions, so it is infeasible to calculate the product of two KZG commitments unless the t-SDH can be solved. Even if the verifier is given the powers of the KZG commitments, it is inefficient to perform scalar multiplications for two commitments (imagine the time complexity of multiplying two $d$-degree polynomials is $O(d^2)$), which implies this method is hard to be succinct.</p><p>The second method is more general and widely used. The basic idea is instead of proving the commitments satisfy the conditions, the prover reveals the evaluations of the polynomials at a random point sent by the verifier to prove the evaluations satisfy the conditions; at the same time, the prover proves the evaluations are valid through the binding property of KZG commitment. This method works because of the Schwartz-Zippel lemma, which tells us if the equation (of the polynomials) holds at a random evaluation point on the domain $\mathcal{H}_\kappa$, then it holds at any point on $\mathcal{H}_\kappa$ with high probability. The probability is $d/|\mathbb{F}|$, where $d$ is the number of roots of the equation and $\mathbb{F}$ is the field of the random evaluation point. This means as long as the field is big enough, the probability of failure is negligible. By rearranging the polynomials, the verifier can challenge any point on the group field rather than $\mathcal{H}_\kappa$, which makes the probability of failure tend to $0$.</p><h2 id=protocol-details>Protocol Details
<a class=anchor href=#protocol-details>#</a></h2><h3 id=array-level>Array Level
<a class=anchor href=#array-level>#</a></h3><ul><li>$\mathcal{P}$ holds a number $\eta\in\mathbb{Z}$</li><li>$\mathcal{P}$ computes or holds an array $\mathsf{T}=[t_0,t_1,t_2,\dots,t_{k-1}]$ of $k$ (recall $k=\lceil\log_2{\eta}\rceil$) integers ($t_i\in\mathbb{Z}$) such that:<ul><li>$\mathsf{T}[0]=\eta$</li><li>$\mathsf{T}[k-1]\in\{0,1\}$</li><li>$\mathsf{T}[i]-2\cdot\mathsf{T}[i+1]\in\{0,1\}$</li></ul></li></ul><h3 id=polynomial-level>Polynomial Level
<a class=anchor href=#polynomial-level>#</a></h3><p>We assume the array $\mathsf{T}$ is encoded as the y-coordinates into a univariant polynomial where the x-coordinates (called the domain $\mathcal{H}_\kappa$) are chosen as the multiplicative group of order $\kappa$ with generator $\omega\in\mathbb{G}_\kappa$ (see <a href=../background/poly-iop.md>Background</a> for more). In short, $\omega^0$ is the first element and $\omega^{\kappa-1}$ is the last element of $\mathcal{H}_\kappa$. If $\kappa$ is larger than the length of the array, the array can be padded with elements of value 0 (which will not change the sum).</p><p>Recall the constraints we want to prove:</p><ol><li>$\mathsf{T}[0]=\eta$</li><li>$\mathsf{T}[k-1]\in\{0,1\}$</li><li>$\mathsf{T}[i]-2\cdot\mathsf{T}[i+1]\in\{0,1\}$</li></ol><p>In polynomial form, the constraints are:</p><ol><li>For $X=\omega^0$: $\mathsf{Poly}_\mathsf{T}(X)=\eta$</li><li>For $X=\omega^{\kappa-1}$: $\mathsf{Poly}_\mathsf{T}(X)\in\{0,1\}$</li><li>For all $X=\mathcal{H}_\kappa\setminus{\omega^{\kappa-1}}$: $\mathsf{Poly}_\mathsf{T}(X)-2\cdot\mathsf{Poly}_\mathsf{T}(X\omega)\in\{0,1\}$</li></ol><p>Note because the value of $\eta$ is a secret, $\mathcal{P}$ will not reveal $\eta$ to let $\mathcal{V}$ verify $\eta$ is the evaluation of $\mathsf{Poly}_\mathsf{T}(\omega^0)$. $\mathcal{P}$ will leverage the hiding property of KZG (Pedersen) commitment to prove the committed $\eta$ is the correct evaluation. Specifically, $\mathcal{P}$ claims the committed $\eta$ is the correct one and opens $\mathsf{Poly}_\mathsf{T}$ at $\omega^0$. If the committed $\eta$ satisfy the KZG verification, $\mathcal{V}$ can believe the first constraint is satisfied.</p><p>We take care of the &ldquo;for $X$&rdquo; conditions of constraints 2 and 3 by zeroing out the rest of the polynomial that is not zero. See the gadget <a href=./zero1>zero1</a> for more on why this works.</p><ol><li>$\mathsf{Poly}_\mathsf{Vanish1}(X)=\mathsf{Poly}_\mathsf{T}(X)\cdot[\mathsf{Poly}_\mathsf{T}(X)-1]\cdot\frac{X^\kappa-1}{X-\omega^{\kappa-1}}=0$</li><li>$\mathsf{Poly}_\mathsf{Vanish2}(X)=[\mathsf{Poly}_\mathsf{T}(X)-2\cdot\mathsf{Poly}_\mathsf{T}(X\omega)]\cdot[\mathsf{Poly}_\mathsf{T}(X)-2\cdot\mathsf{Poly}_\mathsf{T}(X\omega)-1]\cdot(X-\omega^{\kappa-1})=0$</li></ol><p>The two equations are vanishing for every value of $X\in\mathcal{H}_\kappa$ (but not necessarily true outside of these values). To show this, we divide each polynomial by $X^\kappa-1$, which is a minimal vanishing polynomial for $\mathcal{H}_\kappa$ that does not require interpolation to create. If the quotient is polynomial (and not a rational function), then $\mathsf{Poly}_\mathsf{Vanish1}(X)$ and $\mathsf{Poly}_\mathsf{Vanish2}(X)$ must be vanishing on $\mathcal{H}_\kappa$ too. Specifically, the prover computes:</p><ol><li>$Q_1(X) = \frac{\mathsf{Poly}_\mathsf{Vanish1}(X)}{X^\kappa - 1}$</li><li>$Q_2(X) = \frac{\mathsf{Poly}_\mathsf{Vanish2}(X)}{X^\kappa - 1}$</li></ol><p>We can replace polynomials $Q_1(X)$, and $Q_2(X)$ with a single polynomial $Q(X)$. We can do this because all three constraints have the same format: $\mathsf{Poly}_\mathsf{Vanish_i}(X)=0$. The batching technique is to create a new polynomial with all three $\mathsf{Poly}_\mathsf{Vanish_i}(X)$ values as coefficients. If and (overwhelmingly) only if all three are vanishing, then so will the new polynomial. This polynomial will be evaluated at a random challenge point $\rho$ selected after the commitments to the earlier polynomials are fixed.</p><p>$Q(X) = \frac{\mathsf{Poly}_\mathsf{Vanish1}(X)+\rho\cdot\mathsf{Poly}_\mathsf{Vanish2}(X)}{X^n - 1}$</p><p>By rearranging, we can get $\mathsf{Poly}_\mathsf{Zero}(X)$ as a true zero polynomial (zero at every value both in $\mathcal{H}_\kappa$ and outside of it):</p><p>$\mathsf{Poly}_\mathsf{Zero}(X)=\mathsf{Poly}_\mathsf{Vanish1}(X) + \rho\cdot\mathsf{Poly}_\mathsf{Vanish2}(X)-Q(X)\cdot(X^{\kappa-1}-1)=0$</p><p>Ultimately the range gadget will satisfy the following constraints at the Commitment Level:</p><ol><li>Show $Q(X)$ exists (as a polynomial that evenly divides the divisor)</li><li>Show $\mathsf{Poly}_\mathsf{Zero}(X)$ is correctly constructed from $\mathsf{Poly}_\mathsf{T}(X)$</li><li>Show $\mathsf{Poly}_\mathsf{Zero}(X)$ is the zero polynomial</li></ol><h3 id=commitment-level>Commitment Level
<a class=anchor href=#commitment-level>#</a></h3><p>The verifier will never see the arrays or polynomials themselves. They are undisclosed because they either (i) contain private data or (ii) are too large to examine and maintain a succinct proof system. Instead, the prover will use commitments.</p><p>The prover will write the following commitments to the transcript:</p><ul><li>$K_\mathsf{T}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{T}(X))$</li></ul><p>The prover will generate a random challenge evaluation point (using strong Fiat-Shamir) on the polynomial that is outside of $\mathcal{H}_\kappa$. Call this point $\rho$. It will be used by the prover to create polynomial $Q(X)$ (see above) and the prover will write to the transcript:</p><ul><li>$\rho$</li><li>$K_Q=\mathsf{KZG.Commit}(Q(X))$</li></ul><p>The prover will generate a second random challenge evaluation point (using strong Fiat-Shamir) on the polynomial that is outside of $\mathcal{H}_\kappa$. Call this point $\zeta$. The prover will write the point and opening proofs to the transcript:</p><ul><li>$\zeta$</li><li>$\mathsf{Poly}_\mathsf{T}(\zeta)=\mathsf{KZG.Open}(K_\mathsf{T},\zeta)$</li><li>$\mathsf{Poly}_\mathsf{T}(\zeta\omega)=\mathsf{KZG.Open}(K_\mathsf{T},\zeta\omega)$</li><li>$Q(\zeta)=\mathsf{KZG.Open}(K_Q,\zeta)$</li></ul><p>To check the proof, the verifier uses the transcript to construct the value $Y_\mathsf{Zero}$ as follows:</p><ul><li>$Y_\mathsf{Vanish1}=\mathsf{Poly}_\mathsf{T}(\zeta)\cdot[\mathsf{Poly}_\mathsf{T}(\zeta)-1]\cdot\frac{\zeta^\kappa-1}{\zeta-\omega^{\kappa-1}}$</li><li>$Y_\mathsf{Vanish2}=[\mathsf{Poly}_\mathsf{T}(\zeta)-2\cdot\mathsf{Poly}_\mathsf{T}(\zeta\omega)]\cdot[\mathsf{Poly}_\mathsf{T}(\zeta)-2\cdot\mathsf{Poly}_\mathsf{T}(\zeta\omega)-1]\cdot(\zeta-\omega^{\kappa-1})$</li><li>$Y_\mathsf{Zero}=Y_\mathsf{Vanish1}+\rho\cdot{Y_\mathsf{Vanish2}}-Q(\zeta)\cdot(\zeta^n-1)$</li></ul><p>Finally, if the constraint system is true, the following constraint will be true (and will be false otherwise with overwhelming probability, due to the Schwartz-Zippel lemma on $\rho$ and $\zeta$) :</p><ul><li>$Y_\mathsf{Zero}\overset{?}{=}0$</li></ul><h2 id=security-proof>Security Proof
<a class=anchor href=#security-proof>#</a></h2><h3 id=completeness>Completeness
<a class=anchor href=#completeness>#</a></h3><p>Any honest prover can do the computations explained above and create an accepting proof.</p><h3 id=soundness>Soundness
<a class=anchor href=#soundness>#</a></h3><p>We prove knowledge soundness in the Algebraic Group Model (AGM). To do so, we must prove that there exists an efficient extractor $\mathcal{E}$ such that for any algebraic adversary $\mathcal{A}$ the probability of $\mathcal{A}$ winning the following game is $\mathsf{negl}(\lambda)$.</p><ol><li>Given $[g,g^\tau,g^{\tau^2},\dots,g^{\tau^{n-1}}]$, $\mathcal{A}$ outputs commitments to $\mathsf{Poly}_\mathsf{T}(X)$ and $Q$</li><li>$\mathcal{E}$, given access to $\mathcal{A}$&rsquo;s outputs from the previous step, outputs $\mathsf{Poly}_\mathsf{T}(X)$ and $Q$</li><li>$\mathcal{A}$ plays the part of the prover in showing that $Y_\mathsf{Zero}$ is zero at a random challenge $\zeta$</li><li>$\mathcal{A}$ wins if<ul><li>$\mathcal{V}$ accepts at the end of the protocol</li><li>$\eta\notin[0,r]$</li></ul></li></ol><p>Our proof is as follows:</p><p>First, we prove $\eta\ge{0}$. To make $\mathsf{Poly}_\mathsf{Vanish1}$ exist, the last value of $\mathsf{T}$ must be zero or one. From $\mathsf{Poly}_\mathsf{Vanish2}$, it can be observed that $\mathsf{T}[i]\ge\mathsf{T}[i+1]$ for all $i\in[0,\kappa-2]$. Thus, $\mathsf{T}[0]$ is equal to or greater than $\mathsf{T}[\kappa-1]$, i.e., $\eta\ge{0}$.</p><p>Second, we prove $\eta\le{r}$. For simplicity, we assume $r$ is the power of two (recall $\kappa=\log_2{r}$). From $\mathsf{Poly}_\mathsf{Vanish2}$, we know $\mathsf{T}[0]$ is less than or equal to $2^\kappa$. Therefore, $\eta\le{r}$.</p><h3 id=zero-knowledge>Zero-Knowledge
<a class=anchor href=#zero-knowledge>#</a></h3><p>To prove the above protocol is zero-knowledge, we do so by constructing a probabilistic polynomial time simulator $\mathcal{S}$ which, for every (possibly malicious) verifier $\mathcal{V}$, can output a view of the execution of the protocol that is indistinguishable from the view produced by the real execution of the program.</p><p>The simulator $\mathcal{S}$ randomly generates an $\eta^*$, then follows the same steps a prover would prove the lookup argument. $\mathcal{S}$ computes $\mathsf{T^*}$ and interpolates $\mathsf{Poly}_\mathsf{T^*}$ from $\mathsf{T^*}$. It computes $Q^*(X)$ and finally outputs the commitments to each of these polynomials (and writes the commitments to the transcript). Then, it generates the random challenge $\zeta^*$ (once again this is by strong Fiat-Shamir). It creates opening proofs for $\mathsf{Poly}_\mathsf{T^*}(\zeta^*),\mathsf{Poly}_\mathsf{T^*}(\zeta^*\omega)$, and $Q^*(\zeta^*)$, and writes these to the transcript as well. Since $\mathcal{S}$ knows each of the above polynomials, it can honestly compute this step and the proof will be accepted by $\mathcal{V}$. The transcript it generates this way will be indistinguishable from a transcript generated from a real execution since $\mathsf{PolyCommit}_\mathsf{Ped}$ has the property of Indistinguishability of Commitments due to the randomization by $h^{\hat{\phi}(x)}$.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#recap-of-types>Recap of types</a></li><li><a href=#relation>Relation</a></li><li><a href=#intuition>Intuition</a></li><li><a href=#protocol-details>Protocol Details</a><ul><li><a href=#array-level>Array Level</a></li><li><a href=#polynomial-level>Polynomial Level</a></li><li><a href=#commitment-level>Commitment Level</a></li></ul></li><li><a href=#security-proof>Security Proof</a><ul><li><a href=#completeness>Completeness</a></li><li><a href=#soundness>Soundness</a></li><li><a href=#zero-knowledge>Zero-Knowledge</a></li></ul></li></ul></nav></div></aside></main></body></html>