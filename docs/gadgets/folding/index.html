<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Folding (Sangria) # The following document is heavily based on the Sangria techincal note and its condensed form.
Intuition # Given a PLONK circuit, and two private input/public input pairs, we want to reduce the work of checking each of these individually to the work of checking one such relation a single time. This is called folding, and the model we explain here for Plonk, specifically, is called Sangria. Before we get into folding, though, let&rsquo;s review how a PLONK circuit works."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://plonkbook.org/docs/gadgets/folding/"><meta property="og:site_name" content="Handbook"><meta property="og:title" content="Handbook"><meta property="og:description" content="Folding (Sangria) # The following document is heavily based on the Sangria techincal note and its condensed form.
Intuition # Given a PLONK circuit, and two private input/public input pairs, we want to reduce the work of checking each of these individually to the work of checking one such relation a single time. This is called folding, and the model we explain here for Plonk, specifically, is called Sangria. Before we get into folding, though, letâ€™s review how a PLONK circuit works."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Folding | Handbook</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=http://plonkbook.org/docs/gadgets/folding/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.6ec6eba6938494757b9fe5011c54cba2af69700e962f29d208fa6852b65853ab.js integrity="sha256-bsbrppOElHV7n+UBHFTLoq9pcA6WLynSCPpoUrZYU6s=" crossorigin=anonymous></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Handbook</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><p><strong>Background</strong></p></li><li><p><a href=/docs/background/overview/>Overview</a></p></li><li><p><a href=/docs/background/poly-iop/>Polynomials</a></p></li><li><p><a href=/docs/background/kzg/>Commitments</a></p></li><li><p><a href=/docs/background/red-tape/>Red Tape</a></p></li><li><p><a href=/docs/background/proofs/>Proofs</a></p></li><li><p><strong>Gadgets</strong></p></li><li><p><a href=/docs/gadgets/zero1/>zero1</a></p></li><li><p><a href=/docs/gadgets/zero2/>zero2</a></p></li><li><p><a href=/docs/gadgets/rotate/>rotate</a></p></li><li><p><a href=/docs/gadgets/add1/>add1</a></p></li><li><p><a href=/docs/gadgets/add2/>add2</a></p></li><li><p><a href=/docs/gadgets/add3/>add3</a></p></li><li><p><a href=/docs/gadgets/mult1/>mult1</a></p></li><li><p><a href=/docs/gadgets/mult2/>mult2</a></p></li><li><p><a href=/docs/gadgets/mult3/>mult3</a></p></li><li><p><a href=/docs/gadgets/encode/>encode</a></p></li><li><p><a href=/docs/gadgets/shuffle1/>shuffle1</a></p></li><li><p><a href=/docs/gadgets/shuffle2/>shuffle2</a></p></li><li><p><a href=/docs/gadgets/lookup1/>lookup1</a></p></li><li><p><a href=/docs/gadgets/lookup2/>lookup2</a></p></li><li><p><a href=/docs/gadgets/concat/>concat</a></p></li><li><p><a href=/docs/gadgets/range/>range</a></p></li><li><p><a href=/docs/gadgets/circuit/>circuit</a></p></li><li><p><a href=/docs/gadgets/folding/ class=active>folding</a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Folding</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#intuition>Intuition</a></li><li><a href=#protocol-details>Protocol Details</a></li><li><a href=#security-proof>Security Proof</a><ul><li><a href=#completeness>Completeness</a></li><li><a href=#soundness>Soundness</a></li><li><a href=#zero-knowledge>Zero-Knowledge</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=folding-sangria>Folding (Sangria)
<a class=anchor href=#folding-sangria>#</a></h1><p>The following document is heavily based on the <a href=https://github.com/geometryxyz/technical_notes/blob/main/sangria_folding_plonk.pdf>Sangria techincal note</a> and its <a href=https://geometry.xyz/notebook/sangria-a-folding-scheme-for-plonk>condensed form</a>.</p><h2 id=intuition>Intuition
<a class=anchor href=#intuition>#</a></h2><p>Given a PLONK circuit, and two private input/public input pairs, we want to reduce the work of checking each of these individually to the work of checking one such relation a single time. This is called folding, and the model we explain here for Plonk, specifically, is called Sangria. Before we get into folding, though, let&rsquo;s review how a PLONK circuit works.</p><p>In <a href=../circuit>circuit</a> we look at how a circuit with a single gate works, but now we generalize to multi-gate circuits. Here we have vectors $\mathsf{L}$, $\mathsf{R}$, $\mathsf{O}$ $\in \mathbb{F}^{s + n +1}$ representing the right and left input, and the output, of each gate, where $n$ is the number of public inputs and $s$ is the number of gates. The $+1$ is an extra row to check the final result, i.e. if the circuit is satisfied. Together, $(\mathsf{L}, \mathsf{R}, \mathsf{O})$ is called the computational trace. These three vectors are divided into $X$, the public inputs, and $W$, the private inputs, or witness. A PLONK proof will show that a public input/private input pair $(X, W)$ satisfies a circuit defined by the tuple $(\mathsf{Q}, \mathsf{S})$, where $\mathsf{Q}$ is the set of selector vectors, and $\mathsf{S}$ is the set of copy contraints. A circuit being satisfied means that the copy constraints are satisfied, and that each gate is satisfied. The $i^{th}$ gate of the circuit is defined as ${q_L}_i \cdot l_i + {q_R}_i \cdot r_i + {q_O}_i \cdot o_i + {q_M}_i \cdot l_i \cdot r_i + {q_c}_i$ where ${q_L}_i, {q_R}_i, {q_O}_i, {q_M}_i, {q_c}_i$ are the $i^{th}$ values of each selector vector, and $l_i, r_i, o_i$ are the $i^{th}$ values of $\mathsf{L}$, $\mathsf{R}$, and $\mathsf{O}$.</p><p>Now, we turn to folding. Say we want to combine the checks for two private input/public input pairs, $(X', W')$ and $(X'', W'')$. We start by trying the most direct appraoch to reducing our two checks down to one: let&rsquo;s take a random linear combination of $(X', W')$ and $(X'', W'')$, and perform the check on it. Then our new private input/public input pair would be $(X, W) := (X' + sX'', W' + sW'')$. We consider this as input to the circuit: $C_{Q,i}(\mathsf{L}, \mathsf{R}, \mathsf{O})$ $= C_{Q,i}(\mathsf{L}' + s\mathsf{L}'', \mathsf{R}' + s\mathsf{R,}'', \mathsf{O} + s\mathsf{O}'')$</p><p>$= {q_L}_i \cdot (l_{i}' + sl_{i}'' ) + {q_R}_i \cdot (r_{i}' + sr_{i}'') + {q_O}_i \cdot (o_{i}' + so_{i}'') + {q_M}_i \cdot (l_{i}' + s1_{i}'') (r_{i}' + sr_{i}'') + {q_C}_i$</p><p>$= {q_L}_i \cdot l_{i}' + {q_L}_i \cdot sl_{i}'' + {q_R}_i \cdot r_{i}' + {q_R}_i \cdot sr_{i}'' + {q_O}_i \cdot o_{i}' + {q_O}_i \cdot so_{i}'' + {q_M}_i \cdot (l_{i}'+ s1_{i}'') (r_{i}' + sr_{i}'') + {q_C}_i$</p><p>$\neq C_{Q,i}(\mathsf{L}', \mathsf{R}', \mathsf{O}')+ C_{Q,i}(\mathsf{L}'', \mathsf{R}'', \mathsf{O}'')$</p><p>We note the result is no longer of the correct form for a PLONK circuit. We end up with an undesirable crossterms, an $s^2$ in front of at least part of $C_{Q,i}(\mathsf{L}'', \mathsf{R}'', \mathsf{O}'')$, and if we want to claim $C_{Q,i}(\mathsf{L}, \mathsf{R}, \mathsf{O}) = C_{Q,i}(\mathsf{L}', \mathsf{R}', \mathsf{O}')+ C_{Q,i}(\mathsf{L}'', \mathsf{R}'', \mathsf{O}'')$, it simply isn&rsquo;t true. This motivates us to define relaxed PLONK gate equations, which will allow us to deal with these issues. Copy constraints are defined the same in relaxed PLONK, but we defined our gates somewhat differently.</p><p>Here, the $i^{th}$ gate is defined as $u({q_L}_i \cdot l_i + {q_R}_i \cdot r_i + {q_O}_i \cdot o_i) + {q_M}_i \cdot l_i \cdot r_i + u^2({q_c}_i) + e_i$ where $u$ is a scalar and $e_i$ is the $i^{th}$ entry in the &ldquo;slack vector&rdquo; $\mathsf{E}$. We now have $(\mathsf{L}, \mathsf{R}, \mathsf{O}, u, \mathsf{E})$ as the computational trace. We must also define our public input/private input pair differently, namely for the regular PLONK pair $(X, W)$ we define the relaxed PLONK pair $(U, V)$ as:</p><p>$U := (X, u, \overline W_l, \overline W_r, \overline W_o, \overline E)$</p><p>$V:= (W, \mathsf{E}, r_l, r_r, r_o, r_e)$</p><p>Where $\overline W_l = \mathsf{com}(w_l, r_l)$, $\overline W_r = \mathsf{com}(w_r, r_r)$, $\overline W_o = \mathsf{com}(w_o, r_o)$, $\overline E = \mathsf{com}(\mathsf{E}, r_e)$. For each of these commitments (and elsewhere in this document) the public parameters are including implicitly for cleaner notation.</p><p>We define the relaxed PLONK gate equation as:</p><p>$C'_{Q,i}= (u) \cdot [{q_L}_i \cdot l + {q_R}_i \cdot r + {q_O}_i \cdot o] + {q_M}_i \cdot l r + u^2{q_C}_i + e_i$</p><p>Note that regular PLONK relation can be represented as a relaxed PLONK relation simply by setting $u=1$ and $\mathsf{E}=\vec{0}$.</p><h2 id=protocol-details>Protocol Details
<a class=anchor href=#protocol-details>#</a></h2><p>Now, we once again try the random linear combination approach, this time with relaxed PLONK gate equations. The verifier is given the verifier key, and the two sets of public inputs $(X', u', \overline W_l', \overline W_r', \overline W_o', \overline E')$ and $(X'', u'', \overline W_l'', \overline W_r'', \overline W_o'', \overline E'')$. The prover has the prover key and both sets of corresponding private inputs: $(W', \mathsf{E}', r_l', r_r', r_o', r_e')$ and $(W'', \mathsf{E}'', r_l'', r_r'', r_o'', r_e'')$. The protocol (which is a public-coin folding scheme) proceeds as follows:</p><ol><li>$\mathcal{P}$ computes $\mathsf{T}= u''(q_L \circ l' + q_R \circ r' + q_O \circ o') + u'(q_L \circ l'' + q_R \circ r'' + q_O \circ o'') + q_M \circ (l' \circ r'' + l'' \circ r') + 2u'u''q_C$ where $\circ$ denotes element-wise multiplication. This $t$ is used to account for the crossterms.</li><li>$\mathcal{P}$ samples a random $r_T$ sends $\overline T = \mathsf{com}(\mathsf{T}, r_T)$.</li><li>$\mathcal{V}$ samples a random challenge $r$ and sends it.</li><li>$\mathcal{P}$ and $\mathcal{V}$ output the folded public input $(X, u, \overline W_l, \overline W_r, \overline W_o, \overline E)$, computed as:</li></ol><p>$\quad X = X' + sX''$</p><p>$\quad u = u' + su''$</p><p>$\quad \overline W_l = \overline W_l' +s\overline W_l''$</p><p>$\quad \overline W_r = \overline W_r' +s\overline W_r''$</p><p>$\quad \overline W_o = \overline W_o' +s\overline W_o''$</p><p>$\quad \overline E = \overline E' -s\overline T + s^2 \overline E''$</p><ol><li>$\mathcal{P}$ outputs the folded private input $(W, \mathsf{E}, r_l, r_r, r_o, r_e)$, computed as:</li></ol><p>$\quad W = W' + sW''$</p><p>$\quad r_l = r_l' +sr_l''$</p><p>$\quad r_r = r_r' +sr_r''$</p><p>$\quad r_o = r_o' +sr_o''$</p><p>$\quad \mathsf{E} = \mathsf{E}' - s\mathsf{T} + s^2 \mathsf{E}''$</p><p>$\quad r_e = r_e' - sr_T + s^2r_e''$</p><p>The resulting public and private inputs constitute a new PLONK pair $(U, V)$ which is the folding of the two input pairs. The protocol can be made non-interactive via Fiat-Shamir.</p><h2 id=security-proof>Security Proof
<a class=anchor href=#security-proof>#</a></h2><h3 id=completeness>Completeness
<a class=anchor href=#completeness>#</a></h3><p>To show completeness, we observe that $C'_{Q,i}(\mathsf{L}, \mathsf{R}, \mathsf{O}, u, \mathsf{E})$</p><p>$= C'_{Q,i}(\mathsf{L}' + s\mathsf{L}'', \mathsf{R}' + s\mathsf{R}'', \mathsf{O}' + s\mathsf{O}'', u' + u'', \mathsf{E}' -s\mathsf{T} + s^2\mathsf{E}'')$</p><p>$= (u' + su'') \cdot [{q_L}_i \cdot (l_i' + sl_i'') + {q_R}_i \cdot (r_i' + sr_i'') + {q_O}_i \cdot (o_i' +so_i'')] + {q_M}_i \cdot (l_i' + sl_i'') (r_i' + sr_i'') + (u' + su'')^2{q_C}_i + e'_i -st_i + s^2 e''_i$</p><p>$= u'(q_{L_i} \cdot l_i' + q_{R_i} \cdot r_i' + q_{O_i} \cdot o_i' + q_{M_i} \cdot l_i' \cdot r_i' + u' \cdot q_{C_i}) + e'_i + u'' \cdot s^2(q_{L_i} \cdot l_i'' + q_{R_i} \cdot r_i'' + q_{O_i} \cdot o_i'' + q_{M_i} \cdot l_i'' \cdot r_i'' + u'' \cdot q_{C_i}) + s^2 e''_i \newline + u''(q_{L_i} \cdot l_i' + q_{R_i} \cdot r_i' + q_{O_i} \cdot oi') + u'(q_{L_i} \cdot li'' + q_{R_i} \cdot r_i'' + q_{O_i} \cdot o_i'') + q_{M_i} \cdot (l_i' \cdot r_i'' + l_i'' \cdot r_i') + 2u'u''q_{C_i} - st_i$</p><p>$= u'(q_{L_i} \cdot l_i' + q_{R_i} \cdot r_i' + q_{O_i} \cdot o_i' + q_{M_i} \cdot l_i' \cdot r_i' + u' \cdot q_{C_i}) + e'_i + u'' \cdot s^2(q_{L_i} \cdot l_i'' + q_{R_i} \cdot r_i'' + q_{O_i} \cdot o_i'' + q_{M_i} \cdot l_i'' \cdot r_i'' + u'' \cdot q_{C_i}) + s^2 e''_i$</p><p>$ = C'_{Q,i}(\mathsf{L}', \mathsf{R}', \mathsf{O}', u, \mathsf{E}') + s^2 \cdot C'_{Q,i}(\mathsf{L}'', \mathsf{R}'', \mathsf{O}'', u, \mathsf{E}'')$</p><p>So following the steps of the protocol above provides a folding that satisfies completeness.</p><h3 id=soundness>Soundness
<a class=anchor href=#soundness>#</a></h3><p>The proof for soundness is rather involved, so we provide the intuition for it here, and the <a href=https://github.com/geometryxyz/technical_notes/blob/main/sangria_folding_plonk.pdf>technical note</a> for Sangria provides the proof in full. We rely on the fact that a binding commitment is used.</p><p>First, we apply the forking lemma for folding (<a href=https://eprint.iacr.org/2021/370.pdf>Nova paper</a> lemma 1), to obtain three transcripts. We then show that, using all three transcripts, the extractor can interpolate the values of $\mathsf{E}', r_e', \mathsf{E}'', r_e''$. It can also interpolate $(W', r_l', r_r', r_o')$ and $(W'', r_l'', r_r'', r_o'')$ using any two of the transcripts. Finally, we show that the traces these values belong to satisfy the copy constraints and the equality for each gate.</p><h3 id=zero-knowledge>Zero-Knowledge
<a class=anchor href=#zero-knowledge>#</a></h3><p>The proof relies on the fact that the commitment used is hiding, then the only message sent by the prover is a hiding commitment, which means the proof is relatively short and straight forward. We define a simulator, $\mathcal{S}$, which samples a random vector $\mathsf{T}$ from $\mathbb{F}^{n + s +1}$ and a random scalar $r_T$ from $\mathbb{F}$. From these, it produces the commitment $\overline T = \mathsf{com}(\mathsf{T}, r_T)$. It then generates a random challenge $r$, and uses this $r$ and $\overline T$ to output the transcript. Since the commitment is hiding, this is computationally indistinguishable from a real transcript.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#intuition>Intuition</a></li><li><a href=#protocol-details>Protocol Details</a></li><li><a href=#security-proof>Security Proof</a><ul><li><a href=#completeness>Completeness</a></li><li><a href=#soundness>Soundness</a></li><li><a href=#zero-knowledge>Zero-Knowledge</a></li></ul></li></ul></nav></div></aside></main></body></html>