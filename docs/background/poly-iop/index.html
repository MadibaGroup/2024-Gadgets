<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Polynomial Interactive Oracle Proofs # Encoding Arrays of Data into Polynomials # Data starts as an array of integers where integers in each slot are between 0 and $q-1$, where $q$ is a large (generally 256 bit) prime number. Recall that we call this set of integers $\mathbb{Z}_q$.
$\mathsf{data}_0$ $\mathsf{data}_1$ $\mathsf{data}_2$ $\mathsf{data}_3$ $\mathsf{data}_4$ It is common to denote a polynomial like $P(X)$ where $X$ is the variable of the polynomial."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://plonkbook.org/docs/background/poly-iop/"><meta property="og:site_name" content="Handbook"><meta property="og:title" content="Handbook"><meta property="og:description" content="Polynomial Interactive Oracle Proofs # Encoding Arrays of Data into Polynomials # Data starts as an array of integers where integers in each slot are between 0 and $q-1$, where $q$ is a large (generally 256 bit) prime number. Recall that we call this set of integers $\mathbb{Z}_q$.
$\mathsf{data}_0$ $\mathsf{data}_1$ $\mathsf{data}_2$ $\mathsf{data}_3$ $\mathsf{data}_4$ It is common to denote a polynomial like $P(X)$ where $X$ is the variable of the polynomial."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Poly Iop | Handbook</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=http://plonkbook.org/docs/background/poly-iop/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.6d49e6d62f7a22810d59163850ad225ab79a5baf5608bfeea8d7c48676951f3e.js integrity="sha256-bUnm1i96IoENWRY4UK0iWreaW69WCL/uqNfEhnaVHz4=" crossorigin=anonymous></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Handbook</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><p><strong>Background</strong></p></li><li><p><a href=/docs/background/overview/>Overview</a></p></li><li><p><a href=/docs/background/kzg/>KZG</a></p></li><li><p><a href=/docs/background/poly-iop/ class=active>Poly IOP</a></p></li><li><p><a href=/docs/background/red-tape/>Red Tape</a></p></li><li><p><a href=/docs/background/proofs/>Proofs</a></p></li><li><p><strong>Gadgets</strong></p></li><li><p><a href=/docs/gadgets/zero1/>zero1</a></p></li><li><p><a href=/docs/gadgets/zero2/>zero2</a></p></li><li><p><a href=/docs/gadgets/rotate/>rotate</a></p></li><li><p><a href=/docs/gadgets/add1/>add1</a></p></li><li><p><a href=/docs/gadgets/add2/>add2</a></p></li><li><p><a href=/docs/gadgets/add3/>add3</a></p></li><li><p><a href=/docs/gadgets/mult1/>mult1</a></p></li><li><p><a href=/docs/gadgets/mult2/>mult2</a></p></li><li><p><a href=/docs/gadgets/mult3/>mult3</a></p></li><li><p><a href=/docs/gadgets/encode/>encode</a></p></li><li><p><a href=/docs/gadgets/shuffle1/>shuffle1</a></p></li><li><p><a href=/docs/gadgets/shuffle2/>shuffle2</a></p></li><li><p><a href=/docs/gadgets/lookup1/>lookup1</a></p></li><li><p><a href=/docs/gadgets/lookup2/>lookup2</a></p></li><li><p><a href=/docs/gadgets/concat/>concat</a></p></li><li><p><a href=/docs/gadgets/range/>range</a></p></li><li><p><a href=/docs/gadgets/circuit/>circuit</a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Poly Iop</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#encoding-arrays-of-data-into-polynomials>Encoding Arrays of Data into Polynomials</a><ul><li><a href=#encoding-1-coefficients>Encoding 1: Coefficients</a></li><li><a href=#encoding-2-evaluation-points>Encoding 2: Evaluation Points</a></li><li><a href=#encoding-3-roots>Encoding 3: Roots</a></li><li><a href=#decision-tree-for-encoding>Decision Tree for Encoding</a></li></ul></li><li><a href=#optimizing-interpolation-roots-of-unity--fft>Optimizing Interpolation (Roots of Unity + FFT)</a></li><li><a href=#zeroing-parts-of-an-array>Zeroing Parts of an Array</a></li><li><a href=#additional-text-to-merge>Additional Text to Merge</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=polynomial-interactive-oracle-proofs>Polynomial Interactive Oracle Proofs
<a class=anchor href=#polynomial-interactive-oracle-proofs>#</a></h1><h2 id=encoding-arrays-of-data-into-polynomials>Encoding Arrays of Data into Polynomials
<a class=anchor href=#encoding-arrays-of-data-into-polynomials>#</a></h2><p>Data starts as an array of integers where integers in each slot are between 0 and $q-1$, where $q$ is a large (generally 256 bit) prime number. Recall that we call this set of integers $\mathbb{Z}_q$.</p><table><thead><tr><th>$\mathsf{data}_0$</th><th>$\mathsf{data}_1$</th><th>$\mathsf{data}_2$</th><th>$\mathsf{data}_3$</th><th>$\mathsf{data}_4$</th></tr></thead></table><p>It is common to denote a polynomial like $P(X)$ where $X$ is the variable of the polynomial. We are going denote the variable with an empty box $\square$ which can be interpreted as a place where you can put any integer in $\mathbb{Z}_q$ you want evaluated (or equivalent, where you place an x-coordinate to learn what the y-coordinate is).</p><p>A polynomial in this notation looks like:</p><ul><li>$P(\square)=c_0+c_1\cdot\square+c_2\cdot\square^2+c_3\cdot\square^3+c_4\cdot\square^4=\sum_{i=0}^d c_i\cdot\square^i$</li></ul><p>The values $c_i$ are called coefficients. Different arrays of data will (depending on how data is encoded, next) result in different coefficients and thus different polynomials. The degree of the polynomial is the largest exponent. So the polynomial above has degree 4 and thus will have 5 coefficients and 5 terms of the form $c_i\cdot\square^i$ (including $i=0$). Sometimes the coefficient will be zero: the term is thus not written down but in a list of coefficients, it will be included as a 0.</p><p>The main question to tackle is how to &ldquo;encode&rdquo; an array of integers into a polynomial. This is generally done one of three ways:</p><ol><li>Coefficients</li><li>Evaluation Points</li><li>Roots</li></ol><p>Each has its advantages and disadvantages, which we discuss next.</p><p>Fast forwarding a bit, once the polynomial is created, it is not shared directly with anyone. Instead, a commitment to it is shared. The commitment does two things: (1) it makes it succinct: e.g., constant size regardless of how long the array is; and (2) it can hide the data in the array as necessary. We will discuss one specific polynomial commitment scheme called KZG. KZG needs the polynomial in the format of a list of its coefficients. If we have the polynomial in a different form, we will have to convert it to coefficients. Thus this needs to be considered when weighing the pros/cons of the three encoding methods.</p><h3 id=encoding-1-coefficients>Encoding 1: Coefficients
<a class=anchor href=#encoding-1-coefficients>#</a></h3><p>Create polynomial as: $P_1(\square)=\mathsf{data}_0+\square+\mathsf{data}_2\cdot\square^2+\mathsf{data}_3\cdot\square^3+\mathsf{data}_4\cdot\square^4=\sum_{i=0}^d \mathsf{data}_i\cdot\square^i$</p><p>Properties:</p><ul><li>Fast üëç: fastest path to commitment as the output is already in coefficient form.</li><li>Addition üëç: two arrays can be added together (slot-by-slot) by simply adding the polynomials together</li><li>Multiplication üëé: no support for multiplication of arrays (Remark: multiplying the polynomials does not multiply the coefficients. It results in a cross multiplication of every term in the first polynomial with every term in the second polynomial. Further the degree of the resulting polynomial will double that of the starting polynomials).</li><li>Opening ü§∑üèª: proving the value of the $i$th element in the array is $\mathsf{data}_i$ doing polynomial math on $P_1(\square)$ is not possible. However $\Sigma$-protocols done directly on KZG may enable this kind of proof. In any case, this is not particularly well explored.</li><li>Other useful properties üëç: the sum of all values in a array can be computed by evaluating the polynomial at $P_1(\boxed{1})$! $\sum_{i=0}^d \mathsf{data}_i\cdot\boxed{1}^i=\sum_{i=0}^d \mathsf{data}_i$ . You can also show two arrays have the same sum (called a &ldquo;sum check&rdquo;) by subtracting them and showing $P(\boxed{1})=0$.</li><li>Other useful properties üëç: when all coefficients are 0, the polynomial will be the zero polynomial ($P_1(\square)=0$). Coefficients can be entire polynomials, not just integers. A common optimization in Poly-IOP systems is taking a set of equations of polynomials that should equal 0, placing each into the coefficient of a super-polynomial, and showing the super-polynomial is the zero polynomial (which can be proven overwhelmingly by showing it is 0 at a randomly selected point).</li></ul><h3 id=encoding-2-evaluation-points>Encoding 2: Evaluation Points
<a class=anchor href=#encoding-2-evaluation-points>#</a></h3><p>Create a list of points $\{x,y\}$ for the data: $\langle\{0,\mathsf{data}_0\},\{1,\mathsf{data}_1\},\{2,\mathsf{data}_2\},\{3,\mathsf{data}_3\},\{4,\mathsf{data}_4\}\rangle$ and interpolate a polynomial $P_2(\square)$ through these points.</p><p>Properties:</p><ul><li>Slow (or moderate) üëé: converting a set of points into a set of coefficients is called interpolation and is $O(n^2)$ time generally. A certain optimization allows $O(n\log n)$ time by chosing $x$ coordinates with a mathematical relationship (more on this later).</li><li>Addition üëç: two arrays can be added together (slot-by-slot) by simply adding the polynomials together</li><li>Multiplication üëç: two arrays can be multiplied together (slot-by-slot) by simply multiplying the polynomials together</li><li>Opening üëç: proving the value of the $i$th element in the array is $\mathsf{data}_i$ is possible with polynomial math by showing $P_2(\boxed{i})=\mathsf{data}_i$ and KZG has a precise algorithm for this.</li></ul><h3 id=encoding-3-roots>Encoding 3: Roots
<a class=anchor href=#encoding-3-roots>#</a></h3><p>Create polynomial as: $P_3(\square)=(\square-\mathsf{data}_0)(\square-\mathsf{data}_1)(\square-\mathsf{data}_2)(\square-\mathsf{data}_3)(\square-\mathsf{data}_4)$</p><p>Alternatively, create a list of roots $\{x,0\}$ for the data: $\langle\{\mathsf{data}_0,0\},\{\mathsf{data}_1,0\},\{\mathsf{data}_2,0\},\{\mathsf{data}_3,0\},\{\mathsf{data}_4,0\}\rangle$ and interpolate a polynomial $P_3(\square)$ through these points.</p><p>Properties:</p><ul><li>Slow üëé (or moderate): multiplying out naively requires $O(n^2)$ time. Treating as a set of points and interpolating also requires $O(n^2)$ time (because the x-coordinates are the data, they cannot be chosen freely to optimize interpolation). Applying divide and conquer can provide $O(n \log^2 n)$.^[1]</li><li>Addition üëé: two arrays cannot be added from adding (or otherwise manipulating) the polynomials.</li><li>Multiplication üëé: two arrays cannot be multiplied from multiplying (or otherwise manipulating) the polynomials (but you can do a &ldquo;union&rdquo; operation below).</li><li>Opening üëç: proving that a value is in the array somewhere is easy and KZG as a precise algorithm for this (opening a root is the same as opening a point, where the y-coordinate is 0). However you cannot show a value is specifically the $i$th value in the array because the polynomial loses the order of the data in the array (see next property).</li><li>Other useful properties üëç: the order of the data in the array does not matter. The same polynomial will be produced even if the order is changed. This is useful when the array represents a &ldquo;bag&rdquo; of unordered data. You can easily prove two &ldquo;bags&rdquo; of data are the same because the polynomials will be the same. One use-case of this is proving the output of a shuffle/permutation is the same data as the input (just in a different order).</li><li>Other useful properties üëç: multiplying two polynomials results in a concatenation of the data in the arrays (or conjunction/union of the data in both bags). This might be useful in some protocols.</li></ul><p>^[1]: Hat tip Pratyush Mishra.</p><h3 id=decision-tree-for-encoding>Decision Tree for Encoding
<a class=anchor href=#decision-tree-for-encoding>#</a></h3><p>Basically we decide if we specifically need unordered &ldquo;bags&rdquo; of data. If so, encoding as roots is the only option. If not, we consider if we need to ever get the data back from the polynomial. Generally we do and encoding as evaluation points is the most common encoding technique. When do we encode the data and never want it back? Usually when (1) the coefficients are all supposed to be zero so we are just showing that property, or (2) we want back the sum of the data and not the data itself. In these cases, you can still work with evaluation point encoding but it will be faster to just do coefficient encoding.</p><script src=/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"default"})</script><p class=mermaid>flowchart LR;
A[Array to Polynomial] --> B{Is the data unordered?};
B -- Unordered --> C[Roots];
B -- Ordered or don't care --> D{Open data from polynomial later?};
D -- Yes --> E[Evaluation Points];
D -- No --> F[Coefficients];</p><p>The short answer is to start with evaluation point encoding until you realize you need something different.</p><h2 id=optimizing-interpolation-roots-of-unity--fft>Optimizing Interpolation (Roots of Unity + FFT)
<a class=anchor href=#optimizing-interpolation-roots-of-unity--fft>#</a></h2><p>Moving forward, we will assume we are using Encoding 2: Evaluation Points. In short, this means placing the elements of our array into the $y$-coordinates ($\mathsf{data}_i=P(\boxed{x_i})$) of points on the polynomial. Before commiting to $P(\square)$, we need to use interpolation to find the coefficients of the polynomial that is fitted to these points. General interpolation algorithms are $O(n^2)$ work for $n$ evaluation points but this can be reduced to $O(n\log n)$ with an optimization.</p><p>The optimization we will explore enables interpolation via the fast Fourier transform (FFT). It concerns how to choose the $x$-coordinates, which will serve as the index for accessing the data: evaluating $P(X)$ at $x_i$ will reveal $\mathsf{data}_i$. First note, $x$-coordinates are from the exponent group ($Z_q$) and the choices exceed what is feasible to use ($2^{255}$ values in bls). Any subset can be used and interpolated. The optimization is to chose them with a mathematical structure. Specifically, instead an additive sequence (e.g., $0,1,2,3,\ldots$), we use a multiplicative sequence $1,\omega,\omega\cdot\omega,\omega\cdot\omega\cdot\omega,\ldots$ or equivalently: $\omega^0,\omega^1,\omega^2,\ldots,\omega^{\kappa-1}$. Further, the sequence is closed under multiplication which means that next index after $\omega^{\kappa-1}$ wraps back to the first index: $\omega^{k-1} \cdot \omega = \omega^\kappa = \omega^0=1$ (this property is also useful in proving relationships between data in the array and its neighbouring values).</p><p><img src=https://hackmd.io/_uploads/SyQdoMDxC.png alt="Roots of Unity"></p><p>For terminology, we say $\omega$ is a generator with multiplicative order $\kappa$ in $\mathbb{Z}_q$ (or $\omega \in \mathbb{G}_\kappa$). This implies $\omega^\kappa=1$. Rearranging, $\omega=\sqrt[\kappa]{1}$. Thus we can equivalently describe $\omega$ as a $\kappa$-th root of 1. Finally, as 1 is the unity element in $Z_q$, $\omega$ is commonly called a $\kappa$-th root of unity.</p><p>For practical purposes, $\kappa$ represents the length of the longest array of data we can use in our protocol. Where does $\kappa$ come from? Different elements of $Z_q$ will have different multiplicative orders but every order must be a divisor of $q-1$. Thus $\kappa$ is the largest divisor of the exact value of $q$ used in an elliptic curve standard. BLS12-384 has $\kappa=2^{32}$ (for terminology, this called a $2$-adicity of $32$). In summary, we can only encode data arrays of length up to $2^{32}=4,294,967,296$.</p><h2 id=zeroing-parts-of-an-array>Zeroing Parts of an Array
<a class=anchor href=#zeroing-parts-of-an-array>#</a></h2><p>Assuming an input array of size $n$: $\langle \mathsf{data}_0,\mathsf{data}_1,\ldots,\mathsf{data}_{n-1}\rangle$ and input array encoded into the polynomial. This uses &ldquo;Encoding 2&rdquo; from above (evaluation points) and uses &ldquo;Roots of Unity + FFT&rdquo; from above where $\omega\in\mathbb{G}_\kappa$ is a generator for the x-coordinates of the points.</p><p>$\bot$ is an arbitrary non-zero integer.</p><table><thead><tr><th>Operation</th><th>Input Array</th><th>Input Polynomial</th><th>Output Array</th><th>Output Polynomial</th></tr></thead><tbody><tr><td>Zero all</td><td>$\langle 3,1,3,3,7 \rangle$</td><td>$P(X)$</td><td>$\langle 0,0,0,0,0 \rangle$</td><td>$P(X)\cdot(X^n-1)$</td></tr><tr><td>Zero first</td><td>$\langle 3,1,3,3,7 \rangle$</td><td>$P(X)$</td><td>$\langle 0,\bot,\bot,\bot,\bot \rangle$</td><td>$P(X)\cdot(X-\omega^0)$</td></tr><tr><td>Zero last</td><td>$\langle 3,1,3,3,7 \rangle$</td><td>$P(X)$</td><td>$\langle \bot,\bot,\bot,\bot,0 \rangle$</td><td>$P(X)\cdot(X-\omega^{n-1})$</td></tr><tr><td>Zero all but first</td><td>$\langle 3,1,3,3,7 \rangle$</td><td>$P(X)$</td><td>$\langle \bot,0,0,0,0 \rangle$</td><td>$P(X)\cdot\frac{(X^n-1)}{(X-\omega^0)}$</td></tr><tr><td>Zero all but last</td><td>$\langle 3,1,3,3,7 \rangle$</td><td>$P(X)$</td><td>$\langle 0,0,0,0,\bot \rangle$</td><td>$P(X)\cdot\frac{(X^n-1)}{(X-\omega^{n-1})}$</td></tr></tbody></table><p>Why are these useful? Consider a <a href=https://hackmd.io/@dabo/B1U4kx8XI>range proof</a> from Boneh, Fisch, Gabizon, and Williamson. At a certain point in the protocol, we reach the following:</p><p><img src=https://hackmd.io/_uploads/H1Xg2IvgR.png alt="Screenshot 2024-04-12 at 9.11.45 PM"></p><p>First note that $w$ and $\omega$ look the same but are different: $w$ are three new polynomials we are creating, while $\omega$ is the generator of $\mathbb{G}_\kappa$ we are using to pick x-coordinates for the polynomials.</p><ul><li>In the first constraint, we want to prove the value of f(1) and g(1) are the same. So we subtract (g-f) which leaves a zero in the first element of the array but the rest of the array will contain other stuff. By applying &ldquo;zero all but first&rdquo;, we can zero out the rest of the array. We now have an array that is all zero (in polynomial form, this is called a vanshing polynomial and we can prove a polynomial vanishes easily and in a batch).</li><li>In the second constraint, we prove the last element in g is a binary bit (0 or 1) and then we apply the &ldquo;zero all but last&rdquo; to make an array that is all zero (and vanishing polynomial).</li><li>In the third constraint, the first two terms of the multiplication are proving $g(X)$ has a certain form that does not need to be understood here. What is important is that there is a relationship between each integer in the array ($g(X)$) and the integer right beside it ($g(X\omega)$) in the array. When the relationship holds, the result is a zero in $w_3$. Unfortunately, there is a corner case: for the last element in the array, the &ldquo;next&rdquo; integer wraps back to the first integer and the relationship does not hold across this boundary. So we use &ldquo;zero last&rdquo; to manually zero out the last integer in the array, leaving us with a zero array (and vanishing polynomial).</li></ul><h2 id=additional-text-to-merge>Additional Text to Merge
<a class=anchor href=#additional-text-to-merge>#</a></h2><p>The prover interpolates $A$ and $B$ to get $P_A(x)$ and $P_B(x)$. To do so, an $n$th root of unity (which we will call $\omega$) is used, and the values of $A$ and $B$ are paired with the powers of this root of unity as follows: $(\omega^0, a_0), (\omega^1, a_1), \dots, (\omega^{n-1}, a_{n-1})$ and similarly for $B$. Then the interpolation (using the fast fourier transform (FFT)) creates a polynomial that passes through the points represented by these tuples. We also define $H$ as the set $[\omega^0, \omega^1, \dots, \omega^{n-1}]$. We are assuming that $n$ is a power of 2, so that we can use FFT. In practice, if it is not, then a power of 2 greater than $n$, say $2^m$, is used and the last $2^m - n$ entries of $A$ are padded with 1s.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#encoding-arrays-of-data-into-polynomials>Encoding Arrays of Data into Polynomials</a><ul><li><a href=#encoding-1-coefficients>Encoding 1: Coefficients</a></li><li><a href=#encoding-2-evaluation-points>Encoding 2: Evaluation Points</a></li><li><a href=#encoding-3-roots>Encoding 3: Roots</a></li><li><a href=#decision-tree-for-encoding>Decision Tree for Encoding</a></li></ul></li><li><a href=#optimizing-interpolation-roots-of-unity--fft>Optimizing Interpolation (Roots of Unity + FFT)</a></li><li><a href=#zeroing-parts-of-an-array>Zeroing Parts of an Array</a></li><li><a href=#additional-text-to-merge>Additional Text to Merge</a></li></ul></nav></div></aside></main></body></html>