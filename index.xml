<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Plonkbook on Handbook</title><link>http://plonkbook.org/</link><description>Recent content in Plonkbook on Handbook</description><generator>Hugo</generator><language>en-us</language><atom:link href="http://plonkbook.org/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://plonkbook.org/docs/background/poly-iop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/background/poly-iop/</guid><description>Notes on Polynomial Interactive Oracle Proofs (Draft) # Definitions # Definition 1 (Polynomial Commitment Scheme). A polynomial commitment scheme (PCS) is an interactive proof system that enables $\mathcal{P}$ to convince $\mathcal{V}$ that he knows a polynomial, without revealing the polynomial directly. $\mathcal{P}$ and $\mathcal{V}$ run the protocol in three moves: gen, com, and open. [Plonk]
Definition 2 (Polynomial IOP). Let $\mathcal{R}$ be a set of the relations among polynomials $\{P_i\}$.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/add1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/add1/</guid><description>Addition (Type 1) # Recap of types # Type Description Recap This add1 $\mathsf{Arr}_3=\mathsf{Arr}_1 + \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise addition of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. ✅ add2 $\mathsf{Sum}_\mathsf{Arr}=\sum_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Sum}_\mathsf{Arr}$ is the disclosed sum of all the elements in $\mathsf{Arr}$. add3 $\sum_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\sum_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed sum. Relation # $ \mathcal{R}_{\mathtt{add1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr_2},K_\mathsf{Arr_3}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_3}[i]=\mathsf{Arr_1}[i]+\mathsf{Arr_2}[i], 0\leq i \leq n, \\ \mathsf{Poly}_\mathsf{Arr_j}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/add2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/add2/</guid><description>Addition (Type 2) # Recap of types # Type Description Recap This add1 $\mathsf{Arr}_3=\mathsf{Arr}_1 + \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise addition of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. add2 $\mathsf{Sum}_\mathsf{Arr}=\sum_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Sum}_\mathsf{Arr}$ is the disclosed sum of all the elements in $\mathsf{Arr}$. ✅ add3 $\sum_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\sum_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed sum. Relation # $ \mathcal{R}_{\mathtt{add2}} := \left\{ \begin{array}{l} (K_\mathsf{Arr},\mathsf{Sum}_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} \mathsf{Arr} = [a_0, a_1, a_2, \dots, a_{n-1}], \\ \mathsf{Sum}_\mathsf{Arr} = \sum_{i = 0}^{n-1} a_i, \\ \mathsf{Poly}_\mathsf{Arr}(X)=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/add3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/add3/</guid><description>Addition (Type 3) # Recap of types # Type Description Recap This add1 $\mathsf{Arr}_3=\mathsf{Arr}_1 + \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise addition of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. add2 $\mathsf{Sum}_\mathsf{Arr}=\sum_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Sum}_\mathsf{Arr}$ is the disclosed sum of all the elements in $\mathsf{Arr}$. add3 $\sum_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\sum_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed sum. ✅ Relation # $ \mathcal{R}_{\mathtt{add3}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/circuit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/circuit/</guid><description>Circuit # Recap of types # Type Description Recap This circuit $z=\mathsf{Circ}(x,y)$ $z$ is the output of disclosed arithmetic circuit $\mathsf{Circ}$ with disclosed (and/or undisclosed) inputs $x$ and $y$. ✅ Relation # $\mathcal{R}_{\mathtt{circ}} := \left\{ \begin{array}{l} (K_\mathsf{T},K_\mathsf{In}) \end{array} \middle | \begin{array}{l} \mathsf{In}=[i_0,i_1,i_2,i_3], \\ \mathsf{T}=[t_0,t_1,t_2,t_3], \\ \mathsf{T}[3]\in\{0,1\}, \\ \mathsf{T}[3]\cdot(\mathsf{In}[0]\cdot\mathsf{T}[0]+\mathsf{In}[1]\cdot\mathsf{T}[1])+(1-\mathsf{T}[3])\cdot(\mathsf{In}[0]\cdot\mathsf{In}[1]\cdot\mathsf{T}[2])+\mathsf{In}[2]=\mathsf{In}[3], \\ \mathsf{Poly}_\mathsf{T}=\mathsf{FFT.Interp}(\omega,\mathsf{T}), \\ \mathsf{Poly}_\mathsf{In}=\mathsf{FFT.Interp}(\omega,\mathsf{In}), \\ K_\mathsf{T}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{T}), \\ K_\mathsf{In}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{In}) \\ \end{array} \right\}$
Intuition # The prover ($\mathcal{P}$) and the verifier ($\mathcal{V}$) are both given a circuit $\mathsf{T}$, where $\mathsf{T}[0]$ and $\mathsf{T}[1]$ are the factors of the two inputs respectively, $\mathsf{T}[2]$ is the factor of the product of the two inputs, and $\mathsf{T}[3]$ is the selector of the gate ($\mathsf{T}[3]$ is one for addition gate and zero for multiplication gate).</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/encode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/encode/</guid><description>Encode # Relation # $ \mathcal{R}_{\mathtt{mult3}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}, \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr_1}), \\ \mathsf{Poly}_\mathsf{Arr_2}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr_2}), \\ K_\mathsf{Arr_1}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr_1}),\\ K_\mathsf{Arr_2}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr_2}), \end{array} \right\} $
Intuition # The prover ($\mathcal{P}$) holds two arrays $\mathsf{Arr_1}$ and $\mathsf{Arr_2}$ of $n$ integers from $\mathbb{Z}_q$: $[a_0, a_1, a_2, \dots, a_{n-1}]$. It wishes to map the pairs of elements, $\{ \mathsf{Arr_1[i], \mathsf{Arr_2[i]}}\}$ into a single element, $\mathsf{Arr_3}[i]$ without collisions.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/lookup1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/lookup1/</guid><description>Lookup (Type 1) # Recap of types # Type Description Recap This lookup1 $\mathsf{Arr}[i]\in \{0,1\}$ Each element of array $\mathsf{Arr}$ is in $\{0,1\}$ (or another small set). ✅ lookup2 $\mathsf{Arr}[i]\in \mathsf{Table}$ Each element of array $\mathsf{Arr}$ is in a disclosed table of values $\mathsf{Table}$. Relation # $ \mathcal{R}_{\mathtt{lookup1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} \mathsf{Arr} = [a_0, a_1, a_2, \dots, a_{n-1}], \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \end{array} \right\} $</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/lookup2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/lookup2/</guid><description>Lookup (Type 2) # Recap of types # Type Description Recap This lookup1 $\mathsf{Arr}[i]\in \{0,1\}$ Each element of array $\mathsf{Arr}$ is in $\{0,1\}$ (or another small set). lookup2 $\mathsf{Arr}[i]\in \mathsf{Table}$ Each element of array $\mathsf{Arr}$ is in a disclosed table of values $\mathsf{Table}$. ✅ Relation # $ \mathcal{R}_{\mathtt{lookup2}} := \left\{ \begin{array}{l} (\mathsf{Arr},\mathsf{T}) \end{array} \middle | \begin{array}{l} \mathsf{Arr}[i]\in\mathsf{T}, 0\leq i \leq n-1, \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ \mathsf{Poly}_\mathsf{T}=\mathsf{FFT.Interp}(\omega,\mathsf{T}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \\ K_\mathsf{T}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{T}), \end{array} \right\} $</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/mult1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/mult1/</guid><description>Multiplication (Type 1) # Recap of types # Type Description Recap This mult1 $\mathsf{Arr}_3=\mathsf{Arr}_1 \cdot \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise multiplication of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. ✅ mult2 $\mathsf{Prod}_\mathsf{Arr}=\prod_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Prod}_\mathsf{Arr}$ is the disclosed product of all the elements in $\mathsf{Arr}$. mult3 $\prod_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\prod_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed product. Relation # $ \mathcal{R}_{\mathtt{mult1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr_2},K_\mathsf{Arr_3}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_3}[i]=\mathsf{Arr_1}[i]\cdot\mathsf{Arr_2}[i], 0\leq i \leq n-1, \\ \mathsf{Poly}_\mathsf{Arr_j}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/mult2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/mult2/</guid><description>Multiplication (Type 2) # Recap of types # Type Description Recap This mult1 $\mathsf{Arr}_3=\mathsf{Arr}_1 \cdot \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise multiplication of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. mult2 $\mathsf{Prod}_\mathsf{Arr}=\prod_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Prod}_\mathsf{Arr}$ is the disclosed product of all the elements in $\mathsf{Arr}$. ✅ mult3 $\prod_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\prod_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed product. Relation # $ \mathcal{R}_{\mathtt{mult2}} := \left\{ \begin{array}{l} (K_\mathsf{Arr},\mathsf{Prod}_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} \mathsf{Arr} = [a_0, a_1, a_2, \dots, a_{n-1}], \\ \mathsf{Prod}_\mathsf{Arr} = \prod_{i = 0}^{n-1} a_i, \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/mult3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/mult3/</guid><description>Multiplication (Type 3) # Recap of types # Type Description Recap This mult1 $\mathsf{Arr}_3=\mathsf{Arr}_1 \cdot \mathsf{Arr}_2$ $\mathsf{Arr}_3$ is the element-wise multiplication of $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$. mult2 $\mathsf{Prod}_\mathsf{Arr}=\prod_{i = 0}^{n-1} \mathsf{Arr}[i]$ $\mathsf{Prod}_\mathsf{Arr}$ is the disclosed product of all the elements in $\mathsf{Arr}$. mult3 $\prod_{i = 0}^{n-1} \mathsf{Arr}_1[i]=\prod_{i = 0}^{n-1} \mathsf{Arr}_2[i]$ $\mathsf{Arr}_1$ and $\mathsf{Arr}_2$ have the same undisclosed product. ✅ Relation # $ \mathcal{R}_{\mathtt{mult3}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/range/</guid><description>Range # Recap of types # Type Description Recap This range $\mathsf{Arr}[i]\in[0,r]$ Each element of array $\mathsf{Arr}$ is in the range $[0,r]$ ✅ Relation # $\mathcal{R}_{\mathtt{add1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} 0\le{\mathsf{Arr}[i]}\le{r}, i\in[0,n), \\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}), \end{array} \right\}$
Intuition # To prove each element of array $\mathsf{Arr}$ is in the range $[0,r]$, one of the most intuitive ways is we create a vector containing the numbers from $0$ to $r$ and run the lookup argument for $\mathsf{Arr}$.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/rotate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/rotate/</guid><description>Rotate # Relation # $ \mathcal{R}_{\mathtt{rotate}} := \left\{ \begin{array}{l} (K_\mathsf{Arr}) \end{array} \middle | \begin{array}{l} \mathsf{Arr} = [a_0, a_1, a_2, \dots, a_{n-1}],\\ \mathsf{Poly}_\mathsf{Arr}=\mathsf{FFT.Interp}(\omega,\mathsf{Arr}), \\ K_\mathsf{Arr}=\mathsf{KZG.Commit}(\mathsf{Poly}_\mathsf{Arr}),\\ \end{array} \right\} $
Intuition # Assume $\mathsf{Arr}$ is an array of data of size $n$. It is encoded as the y-coordinates into univariant polynomials where the x-coordinates (called the domain $\mathcal{H}_\kappa$) are chosen as the multiplicative group of order $\kappa$ with generator $\omega\in\mathbb{G}_\kappa$ (see Background for more).</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/shuffle1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/shuffle1/</guid><description>Shuffle (Type 1) # Recap of types # Type Description Recap This shuffle1 $\mathsf{Arr}_2=\mathsf{Permute}(\mathsf{Arr}_1)$ Array $\mathsf{Arr}_2$ is a shuffle of $\mathsf{Arr}_1$ for some undisclosed permutation $\pi$. ✅ shuffle2 $\mathsf{Arr}_2=\mathsf{Permute}(\mathsf{Arr}_1 ,\pi)$ Array $\mathsf{Arr}_2$ is a shuffle of $\mathsf{Arr}_1$ under a disclosed permutation $\pi$. Relation # $ \mathcal{R}_{\mathtt{shuffle1}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}) \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/shuffle2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/shuffle2/</guid><description>Shuffle (Type 2) # Recap of types # Type Description Recap This shuffle1 $\mathsf{Arr}_2=\mathsf{Permute}(\mathsf{Arr}_1)$ Array $\mathsf{Arr}_2$ is a shuffle of $\mathsf{Arr}_1$ for some undisclosed permutation $\pi$. shuffle2 $\mathsf{Arr}_2=\mathsf{Permute}(\mathsf{Arr}_1 ,\pi)$ Array $\mathsf{Arr}_2$ is a shuffle of $\mathsf{Arr}_1$ under a disclosed permutation $\pi$. ✅ Relation # $\mathcal{R}_{\mathtt{shuffle2}} := \left\{ \begin{array}{l} (K_\mathsf{Arr_1},K_\mathsf{Arr2}, K_\pi) \end{array} \middle | \begin{array}{l} \mathsf{Arr_1} = [a_{(1,0)}, a_{(1,1)}, a_{(1,2)}, \dots, a_{(1,n-1)}],\\ \mathsf{Arr_2} = [a_{(2,0)}, a_{(2,1)}, a_{(2,2)}, \dots, a_{(2,n-1)}], \\ \mathsf{Arr_\pi} = [\pi(\omega^0), \pi(\omega^1), \pi(\omega^2), \dots, \pi(\omega^{n-1})], \\ \mathsf{Poly}_\mathsf{Arr_1}=\mathsf{FFT.</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/zero1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/zero1/</guid><description>Zeroing Parts of an Array # Assuming an input array of size $n$: $\langle \mathsf{data}_0,\mathsf{data}_1,\ldots,\mathsf{data}_{n-1}\rangle$ and input array encoded into the polynomial. This uses &amp;ldquo;Encoding 2&amp;rdquo; from above (evaluation points) and uses &amp;ldquo;Roots of Unity + FFT&amp;rdquo; from above where $\omega\in\mathbb{G}_\kappa$ is a generator for the x-coordinates of the points.
$\bot$ is an arbitrary non-zero integer.
Operation Input Array Input Polynomial Output Array Output Polynomial Zero all $\langle 3,1,3,3,7 \rangle$ $P(X)$ $\langle 0,0,0,0,0 \rangle$ $P(X)\cdot(X^\kappa-1)$ Zero first $\langle 3,1,3,3,7 \rangle$ $P(X)$ $\langle 0,\bot,\bot,\bot,\bot \rangle$ $P(X)\cdot(X-\omega^0)$ Zero last $\langle 3,1,3,3,7 \rangle$ $P(X)$ $\langle \bot,\bot,\bot,\bot,0 \rangle$ $P(X)\cdot(X-\omega^{\kappa-1})$ Zero all but first $\langle 3,1,3,3,7 \rangle$ $P(X)$ $\langle \bot,0,0,0,0 \rangle$ $P(X)\cdot\frac{(X^\kappa-1)}{(X-\omega^0)}$ Zero all but last $\langle 3,1,3,3,7 \rangle$ $P(X)$ $\langle 0,0,0,0,\bot \rangle$ $P(X)\cdot\frac{(X^\kappa-1)}{(X-\omega^{\kappa-1})}$ Why are these useful?</description></item><item><title/><link>http://plonkbook.org/docs/gadgets/zero2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://plonkbook.org/docs/gadgets/zero2/</guid><description>#Zeroing Parts of an Array (2)
Assume both $\mathsf{Arr}$ (an array of data) and $\mathsf{Sel}$ (a binary array) are of size $n$. They are encoded as the y-coordinates into univariant polynomials where the x-coordinates (called the domain $\mathcal{H}_\kappa$) are chosen as the multiplicative group of order $\kappa$ with generator $\omega\in\mathbb{G}_\kappa$ (see Background for more). In short, $\omega^0$ is the first element and $\omega^{\kappa-1}$ is the last element of $\mathcal{H}_\kappa$. We call our polynomials $\mathsf{Poly}_\mathsf{Arr}(X)$ and $\mathsf{Poly}_\mathsf{Sel}(X)$.</description></item></channel></rss>